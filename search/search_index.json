{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"itty-router-openapi \u00b6 OpenAPI 3 and 3.1 schema generator and validator for Cloudflare Workers Documentation : https://cloudflare.github.io/itty-router-openapi/ Source Code : https://github.com/cloudflare/itty-router-openapi/ itty-router-openapi is a library that extends itty-router , a powerful and lightweight routing system for Cloudflare Workers, already familiar to many developers, and adds an easy-to-use and compact OpenAPI 3 and 3.1 schema generator and validator. itty-route-openapi can also have class-based routes, allowing the developer to quickly build on top of and extend other endpoints while reusing code. The key features are: OpenAPI 3 and 3.1 schema generator Query , Path , Request Body and Header validator Fully written in typescript Class-based endpoints Out of the box OpenAI plugin support Drop-in replacement for existing itty-router applications A template repository is available at cloudflare/workers-sdk , with a live demo here . Why create another router library for workers? \u00b6 This framework built on top of itty-router and extends some of its core features, such as adding class-based endpoints. It also provides a simple and iterative path for migrating from old applications based on itty-router . Building APIs and maintaining good documentation on the parameters and fields of your API hard. However, there is an open standard that makes this documentation process much more effortless, called OpenAPI . OpenAPI \"defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.\" This allows other machines to reliably parse those definitions and use the remote APIs easily, without additional implementation logic. Some of the top requirements for Radar 2.0 were having better API documentation, improving the deployment lifecycle with end-to-end testing, and making it publicly available to Cloudflare customers. OpenAPI support quickly jumped out as the obvious choice to help us on all these fronts. However, we struggled to find an existing OpenAPI framework that checked all our boxes: Easy integration with Cloudflare Workers Input validation for endpoints parameters Actual code-based schema generation (not just generated from comments or manually) Since we couldn't find anything that suited us, as many engineers do, we opted for the second-best alternative: building our own and open-source it. Quick setup \u00b6 Get started fast using the create-cloudflare command line, just run this command to setup an initial project with some example routes: npm create cloudflare@latest hello-world -- --type openapi Then to start the local server just run cd hello-world wrangler dev Installation \u00b6 npm i @cloudflare/itty-router-openapi --save Example \u00b6 Let's create our first class-based endpoint called TaskFetch in src/tasks.ts now. Make sure that \u2018Task' is global, otherwise you must redefine responses.schema.task with every endpoint. When defining the schema, you can interchangeably use native typescript types or use the included types to set required flags, descriptions, and other fields. import { OpenAPIRoute , Path , Str , DateOnly , } from '@cloudflare/itty-router-openapi' const Task = { name : new Str ({ example : 'lorem' }), slug : String , description : new Str ({ required : false }), completed : Boolean , due_date : new DateOnly (), } export class TaskFetch extends OpenAPIRoute { static schema = { tags : [ 'Tasks' ], summary : 'Get a single Task by slug' , parameters : { taskSlug : Path ( Str , { description : 'Task slug' , }), }, responses : { '200' : { schema : { metaData : {}, task : Task , }, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // Retrieve the validated slug const { taskSlug } = data // Actually fetch a task using the taskSlug return { metaData : { meta : 'data' }, task : { name : 'my task' , slug : taskSlug , description : 'this needs to be done' , completed : false , due_date : new Date (). toISOString (). slice ( 0 , 10 ), }, } } } Now initialize a new OpenAPIRouter, and reference our newly created endpoint as a regular \u2018itty-router\u2019 .get route: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { TaskFetch } from './tasks' const router = OpenAPIRouter () router . get ( '/api/tasks/:taskSlug/' , TaskFetch ) // 404 for everything else router . all ( '*' , () => new Response ( 'Not Found.' , { status : 404 })) export default { fetch : router.handle , } Finally, run wrangler dev and head to /docs our /redocs with your browser. You'll be greeted with a beautiful OpenAPI page that you can use to test and call your new endpoint. Pretty easy, right? Feedback and contributions \u00b6 itty-router-openapi aims to be at the core of new APIs built using Workers and define a pattern to allow everyone to have an OpenAPI-compliant schema without worrying about implementation details or reinventing the wheel. itty-router-openapi is considered stable and production ready and is being used with the Radar 2.0 public API . Currently this package is maintained by the Cloudflare Radar Team and features are prioritized based on the Radar roadmap. Nonetheless you can still open pull requests or issues in this repository and they will get reviewed. You can also talk to us in the Cloudflare Community or the Radar Discord Channel","title":"itty-router-openapi"},{"location":"#itty-router-openapi","text":"OpenAPI 3 and 3.1 schema generator and validator for Cloudflare Workers Documentation : https://cloudflare.github.io/itty-router-openapi/ Source Code : https://github.com/cloudflare/itty-router-openapi/ itty-router-openapi is a library that extends itty-router , a powerful and lightweight routing system for Cloudflare Workers, already familiar to many developers, and adds an easy-to-use and compact OpenAPI 3 and 3.1 schema generator and validator. itty-route-openapi can also have class-based routes, allowing the developer to quickly build on top of and extend other endpoints while reusing code. The key features are: OpenAPI 3 and 3.1 schema generator Query , Path , Request Body and Header validator Fully written in typescript Class-based endpoints Out of the box OpenAI plugin support Drop-in replacement for existing itty-router applications A template repository is available at cloudflare/workers-sdk , with a live demo here .","title":"itty-router-openapi"},{"location":"#why-create-another-router-library-for-workers","text":"This framework built on top of itty-router and extends some of its core features, such as adding class-based endpoints. It also provides a simple and iterative path for migrating from old applications based on itty-router . Building APIs and maintaining good documentation on the parameters and fields of your API hard. However, there is an open standard that makes this documentation process much more effortless, called OpenAPI . OpenAPI \"defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.\" This allows other machines to reliably parse those definitions and use the remote APIs easily, without additional implementation logic. Some of the top requirements for Radar 2.0 were having better API documentation, improving the deployment lifecycle with end-to-end testing, and making it publicly available to Cloudflare customers. OpenAPI support quickly jumped out as the obvious choice to help us on all these fronts. However, we struggled to find an existing OpenAPI framework that checked all our boxes: Easy integration with Cloudflare Workers Input validation for endpoints parameters Actual code-based schema generation (not just generated from comments or manually) Since we couldn't find anything that suited us, as many engineers do, we opted for the second-best alternative: building our own and open-source it.","title":"Why create another router library for workers?"},{"location":"#quick-setup","text":"Get started fast using the create-cloudflare command line, just run this command to setup an initial project with some example routes: npm create cloudflare@latest hello-world -- --type openapi Then to start the local server just run cd hello-world wrangler dev","title":"Quick setup"},{"location":"#installation","text":"npm i @cloudflare/itty-router-openapi --save","title":"Installation"},{"location":"#example","text":"Let's create our first class-based endpoint called TaskFetch in src/tasks.ts now. Make sure that \u2018Task' is global, otherwise you must redefine responses.schema.task with every endpoint. When defining the schema, you can interchangeably use native typescript types or use the included types to set required flags, descriptions, and other fields. import { OpenAPIRoute , Path , Str , DateOnly , } from '@cloudflare/itty-router-openapi' const Task = { name : new Str ({ example : 'lorem' }), slug : String , description : new Str ({ required : false }), completed : Boolean , due_date : new DateOnly (), } export class TaskFetch extends OpenAPIRoute { static schema = { tags : [ 'Tasks' ], summary : 'Get a single Task by slug' , parameters : { taskSlug : Path ( Str , { description : 'Task slug' , }), }, responses : { '200' : { schema : { metaData : {}, task : Task , }, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // Retrieve the validated slug const { taskSlug } = data // Actually fetch a task using the taskSlug return { metaData : { meta : 'data' }, task : { name : 'my task' , slug : taskSlug , description : 'this needs to be done' , completed : false , due_date : new Date (). toISOString (). slice ( 0 , 10 ), }, } } } Now initialize a new OpenAPIRouter, and reference our newly created endpoint as a regular \u2018itty-router\u2019 .get route: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { TaskFetch } from './tasks' const router = OpenAPIRouter () router . get ( '/api/tasks/:taskSlug/' , TaskFetch ) // 404 for everything else router . all ( '*' , () => new Response ( 'Not Found.' , { status : 404 })) export default { fetch : router.handle , } Finally, run wrangler dev and head to /docs our /redocs with your browser. You'll be greeted with a beautiful OpenAPI page that you can use to test and call your new endpoint. Pretty easy, right?","title":"Example"},{"location":"#feedback-and-contributions","text":"itty-router-openapi aims to be at the core of new APIs built using Workers and define a pattern to allow everyone to have an OpenAPI-compliant schema without worrying about implementation details or reinventing the wheel. itty-router-openapi is considered stable and production ready and is being used with the Radar 2.0 public API . Currently this package is maintained by the Cloudflare Radar Team and features are prioritized based on the Radar roadmap. Nonetheless you can still open pull requests or issues in this repository and they will get reviewed. You can also talk to us in the Cloudflare Community or the Radar Discord Channel","title":"Feedback and contributions"},{"location":"migrating-to-1.0/","text":"What changed \u00b6 The 1.0 update is a big change from the previous version, mainly focusing on bringing support for Zod everywhere! There are a lot of DX improvements and small issues fixed under the hood, but everything besides the breaking changes bellow should not affect your day to day operations. Breaking changes \u00b6 Regex now must be in the RegExp format instead of string \u00b6 Previously, Regex expressions for the Regex parameter type were strings, but now they are defined using the RegExp format. To upgrade the old expressions, just replace the ' you had before with / : Old version import { Regex } from '@cloudflare/itty-router-openapi' const param = new Regex ( '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$' ) New version import { Regex } from '@cloudflare/itty-router-openapi' const param = new Regex ( /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/ ) Validation errors format is now different \u00b6 Previously, validation errors gave very little information, about what was wrong and where it was wrong. Here's an example of a failing enum validation previously: Old Version { \"errors\" : { \"product\" : \"is not one of available options\" }, \"success\" : false , \"result\" : {} } Here's an example of the same request, but running on the newer itty-router-openapi version New Version { \"errors\" : [ { \"received\" : \"testing\" , \"code\" : \"invalid_enum_value\" , \"options\" : [ \"http\" , \"all\" , \"\" ], \"path\" : [ \"query\" , \"product\" , 0 ], \"message\" : \"Invalid enum value. Expected 'http' | 'all' | '', received 'testing'\" } ], \"success\" : false , \"result\" : {} } As you can see, now we get much more information about what type of validation failed, the path to that field in the request, and available options. raiseUnknownParameters now defaults to true \u00b6 The raiseUnknownParameters flag was introduced recently as a way to make the api more strict during validation. It works by raising an error every time an endpoint receives an unexpected parameter. Until now this flag was opt-in, in order to not break any existing application, but we took this 1.0 opportunity to turn it on by default. You can still disable it in the Router configurations, read more here . Query and path parameters each now have their own object inside the data argument \u00b6 Until now the query and path parameters were at the root of the data argument. Old version export class TaskList extends OpenAPIRoute { static schema = { parameters : { slug : Path ( String ), page : Query ( Int ), }, } async handle ( request : Request , env : any , context : any , data : object ) { // Retrieve the validated page const { page , slug } = data // ... } } This led to some confusion regarding why these fields are placed at the root, while body fields are contained within the body property. Additionally, obtaining a path parameter and a query parameter with the same name wasn't possible. In the new version we moved the path to the params property and the query to the query property of the data object. New version export class TaskList extends OpenAPIRoute { static schema = { parameters : { slug : Path ( String ), page : Query ( Int ), }, } async handle ( request : Request , env : any , context : any , data : object ) { // Retrieve the validated page const { page } = data . query const { slug } = data . params // ... } } Missing optional parameters will also be missing in the validated data object \u00b6 Previously, when a parameter was optional, and you didn't sent it in the request, it would always be set to null in the data object. This posed an issue in distinguishing cases where a parameter was meant to be optional but was actually sent with a value of null . In the new version, optional parameters that are not sent will be left undefined, so now you need to check the parameter is defined before using it.","title":"Migrating to 1.0"},{"location":"migrating-to-1.0/#what-changed","text":"The 1.0 update is a big change from the previous version, mainly focusing on bringing support for Zod everywhere! There are a lot of DX improvements and small issues fixed under the hood, but everything besides the breaking changes bellow should not affect your day to day operations.","title":"What changed"},{"location":"migrating-to-1.0/#breaking-changes","text":"","title":"Breaking changes"},{"location":"migrating-to-1.0/#regex-now-must-be-in-the-regexp-format-instead-of-string","text":"Previously, Regex expressions for the Regex parameter type were strings, but now they are defined using the RegExp format. To upgrade the old expressions, just replace the ' you had before with / : Old version import { Regex } from '@cloudflare/itty-router-openapi' const param = new Regex ( '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$' ) New version import { Regex } from '@cloudflare/itty-router-openapi' const param = new Regex ( /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/ )","title":"Regex now must be in the RegExp format instead of string"},{"location":"migrating-to-1.0/#validation-errors-format-is-now-different","text":"Previously, validation errors gave very little information, about what was wrong and where it was wrong. Here's an example of a failing enum validation previously: Old Version { \"errors\" : { \"product\" : \"is not one of available options\" }, \"success\" : false , \"result\" : {} } Here's an example of the same request, but running on the newer itty-router-openapi version New Version { \"errors\" : [ { \"received\" : \"testing\" , \"code\" : \"invalid_enum_value\" , \"options\" : [ \"http\" , \"all\" , \"\" ], \"path\" : [ \"query\" , \"product\" , 0 ], \"message\" : \"Invalid enum value. Expected 'http' | 'all' | '', received 'testing'\" } ], \"success\" : false , \"result\" : {} } As you can see, now we get much more information about what type of validation failed, the path to that field in the request, and available options.","title":"Validation errors format is now different"},{"location":"migrating-to-1.0/#raiseunknownparameters-now-defaults-to-true","text":"The raiseUnknownParameters flag was introduced recently as a way to make the api more strict during validation. It works by raising an error every time an endpoint receives an unexpected parameter. Until now this flag was opt-in, in order to not break any existing application, but we took this 1.0 opportunity to turn it on by default. You can still disable it in the Router configurations, read more here .","title":"raiseUnknownParameters now defaults to true"},{"location":"migrating-to-1.0/#query-and-path-parameters-each-now-have-their-own-object-inside-the-data-argument","text":"Until now the query and path parameters were at the root of the data argument. Old version export class TaskList extends OpenAPIRoute { static schema = { parameters : { slug : Path ( String ), page : Query ( Int ), }, } async handle ( request : Request , env : any , context : any , data : object ) { // Retrieve the validated page const { page , slug } = data // ... } } This led to some confusion regarding why these fields are placed at the root, while body fields are contained within the body property. Additionally, obtaining a path parameter and a query parameter with the same name wasn't possible. In the new version we moved the path to the params property and the query to the query property of the data object. New version export class TaskList extends OpenAPIRoute { static schema = { parameters : { slug : Path ( String ), page : Query ( Int ), }, } async handle ( request : Request , env : any , context : any , data : object ) { // Retrieve the validated page const { page } = data . query const { slug } = data . params // ... } }","title":"Query and path parameters each now have their own object inside the data argument"},{"location":"migrating-to-1.0/#missing-optional-parameters-will-also-be-missing-in-the-validated-data-object","text":"Previously, when a parameter was optional, and you didn't sent it in the request, it would always be set to null in the data object. This posed an issue in distinguishing cases where a parameter was meant to be optional but was actually sent with a value of null . In the new version, optional parameters that are not sent will be left undefined, so now you need to check the parameter is defined before using it.","title":"Missing optional parameters will also be missing in the validated data object"},{"location":"types/","text":"Types are used everywhere in this framework, from defining parameters to response formats. There are 2 API's to define types in itty-router-open, but we recommend that you choose one and stick to it. Native types Zod types Native types \u00b6 Native types, are referred in this documentation as 3 things that work interchangeably: itty-router-openapi types ( Email , Ipv4 , ...) JavaScript native types ( String , Number , ...) JavaScript variables ( 'myvar' gets parsed as String , and so on for numbers and bools) When these types were defined we tried to make them as simple as possible, tried to add as much compatibility as possible. This is the main reason we support such wide variations. itty-router-openapi types \u00b6 itty-router-openapi types are imported as the following: import { Email , Str } from '@cloudflare/itty-router-openapi' Here is a list of all available itty-router-openapi types and the parameters available Name Arguments Num description example default required Int description example default required Str description example default format required Enumeration description example default values enumCaseSensitive required DateTime description example default required DateOnly description example default required Bool description example default required Regex description example default pattern patternError required Email description example default required Uuid description example default required Hostname description example default required Ipv4 description example default required Ipv6 description example default required All itty-router-openapi types can be instantiated in 3 ways: normal class ( new Email({description: 'user email'}) ) raw class (just Email and itty-router-openapi handles the instantiation) instantiation by parameter location ( Query(Str, { description: 'Task description' }) ) As an example, you could define the same query parameter in these 3 ways: import { Query , Str } from '@cloudflare/itty-router-openapi' const queryDescription1 = Query ( Str ) const queryDescription2 = Query ( new Str ({ description : 'Task description' })) const queryDescription3 = Query ( Str , { description : 'Task description' }) Then use it in a endpoint like this: import { Query , Str , Int , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class Example extends OpenAPIRoute { static schema = { parameters : { description : queryDescription , }, responses : { '200' : { schema : {}, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { return { validatedDescription : data.query.description } } } JavaScript native types \u00b6 JavaScript native types can be used everywhere the itty-router-openapi types are used, sometimes it just makes defining schemas simpler For example here is the same query parameters as above defined as JavaScript native types. In this case you cannot instantiate the type with the new keyword, so you must pass the parameters to the parameter location. import { Query } from '@cloudflare/itty-router-openapi' const queryDescription1 = Query ( String ) const queryDescription3 = Query ( String , { description : 'Task description' }) JavaScript variables \u00b6 The main reason we support JavaScript variables is to make it as simple as possible to define schemas and even set as example. Here is an example of the same end result defined with a variable and as itty-router-openapi type. import { Query } from '@cloudflare/itty-router-openapi' const queryDescription1 = Query ( 'john cena' ) const queryDescription3 = Query ( String , { example : 'john cena' }) Defining request bodies and response schemas is even easier with variables, here is another end result defined as variables and with itty-router-openapi type: export class ExampleVariables extends OpenAPIRoute { static schema = { requestBody : { name : 'john cena' , description : 'John Felix Anthony Cena is an American professional wrestler.' , height : 1.85 , can_be_seen : false , } } async handle ( request : Request , env : any , context : any , data : any ) { // ... } } export class ExampleIttyRouterOpenAPI extends OpenAPIRoute { static schema = { requestBody : { name : new Str ({ example : 'john cena' }), description : new Str ({ example : 'John Felix Anthony Cena is an American professional wrestler.' }), height : new Num ({ example : 1.85 }), can_be_seen : new Bool ({ example : false }), } } async handle ( request : Request , env : any , context : any , data : any ) { // ... } } Defining response bodies is such an easy task with variables, you literaly just have to call your endpoint, and copy-paste the response is your schema. export class ExampleRequestBody extends OpenAPIRoute { static schema = { responses : { '200' : { description : 'Successful Response' , schema : { 'asn' : { 'name' : 'CLOUDFLARENET' , 'nameLong' : '' , 'aka' : 'Cloudflare' , 'asn' : 13335 , 'website' : 'https://www.cloudflare.com' , 'country' : 'US' , 'countryName' : 'United States' , 'orgName' : 'Cloudflare, Inc.' , 'related' : [ { 'name' : 'CLOUDFLARENET-AUS' , 'aka' : '' , 'asn' : 14789 , 'estimatedUsers' : null , }, { 'name' : 'CLOUDFLARENET-SFO' , 'aka' : '' , 'asn' : 394536 , 'estimatedUsers' : null , }, { 'name' : 'CLOUDFLARENET-SFO05' , 'aka' : '' , 'asn' : 395747 , 'estimatedUsers' : null , }, ], }, }, }, }, } async handle ( request : Request , env : any , context : any , data : any , ) { // ... } } Zod types \u00b6 Zod types, are as the name says, types from the Zod library, they are much more verbose than the native types, but allows you to define almost everything supported by the OpenAPI specification, like AnyOf, AllOF, etc. Zod is a TypeScript-first schema declaration and validation library. I'm using the term \"schema\" to broadly refer to any data type, from a simple string to a complex nested object. Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator once and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures. Zod types can be used everywhere the Native types are used (because native types are actually just Zod wrappers). Zod allows you to have a much more granular control over what is a valid input or not. For example you could define a Query parameter that only accepts number bellow or equal to 10 with the following line. import { Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const queryResponseLimit = Query ( z . coerce . number (). lte ( 10 )) Then use it in a endpoint like this: import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class Example extends OpenAPIRoute { static schema = { parameters : { limit : queryResponseLimit , }, responses : { '200' : { schema : {}, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { return { validatedLimit : data.query.limit } } } Read the Zod documentation here ! Generating Zod types for your requests \u00b6 Often, you need to retrieve the request body while maintaining type definitions for that body. If you are using Zod for type validation, this becomes very straightforward! Here's how you can create a TypeScript type for your Zod schema: const Task = z . object ({ name : z.string (), description : z.string (). or ( z . string (). array ()), steps : z.string (). array (), }); type MyTaskType = z . infer < typeof Task > ; Now, you can simply execute the following: const body = request.json<MyTaskType>(); Your body is now correctly typed!","title":"Types"},{"location":"types/#native-types","text":"Native types, are referred in this documentation as 3 things that work interchangeably: itty-router-openapi types ( Email , Ipv4 , ...) JavaScript native types ( String , Number , ...) JavaScript variables ( 'myvar' gets parsed as String , and so on for numbers and bools) When these types were defined we tried to make them as simple as possible, tried to add as much compatibility as possible. This is the main reason we support such wide variations.","title":"Native types"},{"location":"types/#itty-router-openapi-types","text":"itty-router-openapi types are imported as the following: import { Email , Str } from '@cloudflare/itty-router-openapi' Here is a list of all available itty-router-openapi types and the parameters available Name Arguments Num description example default required Int description example default required Str description example default format required Enumeration description example default values enumCaseSensitive required DateTime description example default required DateOnly description example default required Bool description example default required Regex description example default pattern patternError required Email description example default required Uuid description example default required Hostname description example default required Ipv4 description example default required Ipv6 description example default required All itty-router-openapi types can be instantiated in 3 ways: normal class ( new Email({description: 'user email'}) ) raw class (just Email and itty-router-openapi handles the instantiation) instantiation by parameter location ( Query(Str, { description: 'Task description' }) ) As an example, you could define the same query parameter in these 3 ways: import { Query , Str } from '@cloudflare/itty-router-openapi' const queryDescription1 = Query ( Str ) const queryDescription2 = Query ( new Str ({ description : 'Task description' })) const queryDescription3 = Query ( Str , { description : 'Task description' }) Then use it in a endpoint like this: import { Query , Str , Int , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class Example extends OpenAPIRoute { static schema = { parameters : { description : queryDescription , }, responses : { '200' : { schema : {}, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { return { validatedDescription : data.query.description } } }","title":"itty-router-openapi types"},{"location":"types/#javascript-native-types","text":"JavaScript native types can be used everywhere the itty-router-openapi types are used, sometimes it just makes defining schemas simpler For example here is the same query parameters as above defined as JavaScript native types. In this case you cannot instantiate the type with the new keyword, so you must pass the parameters to the parameter location. import { Query } from '@cloudflare/itty-router-openapi' const queryDescription1 = Query ( String ) const queryDescription3 = Query ( String , { description : 'Task description' })","title":"JavaScript native types"},{"location":"types/#javascript-variables","text":"The main reason we support JavaScript variables is to make it as simple as possible to define schemas and even set as example. Here is an example of the same end result defined with a variable and as itty-router-openapi type. import { Query } from '@cloudflare/itty-router-openapi' const queryDescription1 = Query ( 'john cena' ) const queryDescription3 = Query ( String , { example : 'john cena' }) Defining request bodies and response schemas is even easier with variables, here is another end result defined as variables and with itty-router-openapi type: export class ExampleVariables extends OpenAPIRoute { static schema = { requestBody : { name : 'john cena' , description : 'John Felix Anthony Cena is an American professional wrestler.' , height : 1.85 , can_be_seen : false , } } async handle ( request : Request , env : any , context : any , data : any ) { // ... } } export class ExampleIttyRouterOpenAPI extends OpenAPIRoute { static schema = { requestBody : { name : new Str ({ example : 'john cena' }), description : new Str ({ example : 'John Felix Anthony Cena is an American professional wrestler.' }), height : new Num ({ example : 1.85 }), can_be_seen : new Bool ({ example : false }), } } async handle ( request : Request , env : any , context : any , data : any ) { // ... } } Defining response bodies is such an easy task with variables, you literaly just have to call your endpoint, and copy-paste the response is your schema. export class ExampleRequestBody extends OpenAPIRoute { static schema = { responses : { '200' : { description : 'Successful Response' , schema : { 'asn' : { 'name' : 'CLOUDFLARENET' , 'nameLong' : '' , 'aka' : 'Cloudflare' , 'asn' : 13335 , 'website' : 'https://www.cloudflare.com' , 'country' : 'US' , 'countryName' : 'United States' , 'orgName' : 'Cloudflare, Inc.' , 'related' : [ { 'name' : 'CLOUDFLARENET-AUS' , 'aka' : '' , 'asn' : 14789 , 'estimatedUsers' : null , }, { 'name' : 'CLOUDFLARENET-SFO' , 'aka' : '' , 'asn' : 394536 , 'estimatedUsers' : null , }, { 'name' : 'CLOUDFLARENET-SFO05' , 'aka' : '' , 'asn' : 395747 , 'estimatedUsers' : null , }, ], }, }, }, }, } async handle ( request : Request , env : any , context : any , data : any , ) { // ... } }","title":"JavaScript variables"},{"location":"types/#zod-types","text":"Zod types, are as the name says, types from the Zod library, they are much more verbose than the native types, but allows you to define almost everything supported by the OpenAPI specification, like AnyOf, AllOF, etc. Zod is a TypeScript-first schema declaration and validation library. I'm using the term \"schema\" to broadly refer to any data type, from a simple string to a complex nested object. Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator once and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures. Zod types can be used everywhere the Native types are used (because native types are actually just Zod wrappers). Zod allows you to have a much more granular control over what is a valid input or not. For example you could define a Query parameter that only accepts number bellow or equal to 10 with the following line. import { Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const queryResponseLimit = Query ( z . coerce . number (). lte ( 10 )) Then use it in a endpoint like this: import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class Example extends OpenAPIRoute { static schema = { parameters : { limit : queryResponseLimit , }, responses : { '200' : { schema : {}, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { return { validatedLimit : data.query.limit } } } Read the Zod documentation here !","title":"Zod types"},{"location":"types/#generating-zod-types-for-your-requests","text":"Often, you need to retrieve the request body while maintaining type definitions for that body. If you are using Zod for type validation, this becomes very straightforward! Here's how you can create a TypeScript type for your Zod schema: const Task = z . object ({ name : z.string (), description : z.string (). or ( z . string (). array ()), steps : z.string (). array (), }); type MyTaskType = z . infer < typeof Task > ; Now, you can simply execute the following: const body = request.json<MyTaskType>(); Your body is now correctly typed!","title":"Generating Zod types for your requests"},{"location":"advanced-user-guide/ci-cd-pipelines/","text":"CI/CD \u00b6 For CI/CD pipelines, you can read the complete openapi.json schemas by calling the schema property from the router instance. Here is an example of a nodejs script that would pick the schema, make some changes and write it to a file, to be able to be picked from a CI/CD pipeline. import fs from 'fs' import { router } from '../src/router' // Get the Schema from itty-router-openapi const schema = router . schema // Optionaly: update the schema with some costumizations for publishing // Write the final schema fs . writeFileSync ( './public-api.json' , JSON . stringify ( schema , null , 2 ))","title":"CI/CD"},{"location":"advanced-user-guide/ci-cd-pipelines/#cicd","text":"For CI/CD pipelines, you can read the complete openapi.json schemas by calling the schema property from the router instance. Here is an example of a nodejs script that would pick the schema, make some changes and write it to a file, to be able to be picked from a CI/CD pipeline. import fs from 'fs' import { router } from '../src/router' // Get the Schema from itty-router-openapi const schema = router . schema // Optionaly: update the schema with some costumizations for publishing // Write the final schema fs . writeFileSync ( './public-api.json' , JSON . stringify ( schema , null , 2 ))","title":"CI/CD"},{"location":"advanced-user-guide/custom-response-formats/","text":"Describing a binary file: \u00b6 import { OpenAPIRoute , Str } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { summary : 'My summary of a custom pdf file endpoint.' , responses : { '200' : { contentType : 'application/pdf' , schema : new Str ({ format : 'binary' }), }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // ... } } Describing a XML response: \u00b6 import { OpenAPIRoute , Str } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { summary : 'My summary of a custom pdf file endpoint.' , responses : { '200' : { contentType : 'application/xml' , schema : new Obj ( { code : new Str ({ example : '13335' }), name : new Str ({ example : 'Cloudflare' }), type : new Str ({ example : 'asn' }), }, { xml : { name : 'root' } } ), }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // ... } }","title":"Custom response formats"},{"location":"advanced-user-guide/custom-response-formats/#describing-a-binary-file","text":"import { OpenAPIRoute , Str } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { summary : 'My summary of a custom pdf file endpoint.' , responses : { '200' : { contentType : 'application/pdf' , schema : new Str ({ format : 'binary' }), }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // ... } }","title":"Describing a binary file:"},{"location":"advanced-user-guide/custom-response-formats/#describing-a-xml-response","text":"import { OpenAPIRoute , Str } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { summary : 'My summary of a custom pdf file endpoint.' , responses : { '200' : { contentType : 'application/xml' , schema : new Obj ( { code : new Str ({ example : '13335' }), name : new Str ({ example : 'Cloudflare' }), type : new Str ({ example : 'asn' }), }, { xml : { name : 'root' } } ), }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // ... } }","title":"Describing a XML response:"},{"location":"advanced-user-guide/event-listener-worker/","text":"Worker using addEventListener \u00b6 If you want to use the addEventListener instead of exporting an object, you can define your worker like this: import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) addEventListener ( 'fetch' , ( event ) => event . respondWith ( router . handle ( event . request ))) You can also pass other event parameters to the endpoint, by adding them in the addEventListener function import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , waitUntil : any , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) addEventListener ( 'fetch' , ( event ) => event . respondWith ( router . handle ( event . request , event . waitUntil . bind ( event )))) Notice that, in this last example the endpoint is receiving an extra waitUntil parameter. Learn more about Cloudflare Workers addEventListener here .","title":"Worker using addEventListener"},{"location":"advanced-user-guide/event-listener-worker/#worker-using-addeventlistener","text":"If you want to use the addEventListener instead of exporting an object, you can define your worker like this: import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) addEventListener ( 'fetch' , ( event ) => event . respondWith ( router . handle ( event . request ))) You can also pass other event parameters to the endpoint, by adding them in the addEventListener function import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , waitUntil : any , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) addEventListener ( 'fetch' , ( event ) => event . respondWith ( router . handle ( event . request , event . waitUntil . bind ( event )))) Notice that, in this last example the endpoint is receiving an extra waitUntil parameter. Learn more about Cloudflare Workers addEventListener here .","title":"Worker using addEventListener"},{"location":"advanced-user-guide/hiding-routes-in-openapi-schema/","text":"Hiding routes can be archived by registering your endpoints in the original itty-router ,as shown here: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () router . original . get ( '/todos/:id' , ({ params }) => new Response ( `Todo # ${ params . id } ` ) ) This endpoint will still be accessible, but will not be shown in the schema. Defining redirects \u00b6 This is also useful to define redirects, like this: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { TaskFetch } from './tasks' const router = OpenAPIRouter () // Redirect to docs page router . original . get ( '/' , ( request ) => Response . redirect ( ` ${ request . url } docs` , 302 )) export default { fetch : router.handle , }","title":"Hiding routes in openapi schema"},{"location":"advanced-user-guide/hiding-routes-in-openapi-schema/#defining-redirects","text":"This is also useful to define redirects, like this: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { TaskFetch } from './tasks' const router = OpenAPIRouter () // Redirect to docs page router . original . get ( '/' , ( request ) => Response . redirect ( ` ${ request . url } docs` , 302 )) export default { fetch : router.handle , }","title":"Defining redirects"},{"location":"advanced-user-guide/openai-plugin/","text":"OpenAI plugin support \u00b6 In the aiPlugin field you can define all fields from the plugin manifest This library include default values for the following plugin manifest fields: import { AuthType , SchemaVersion , APIType } from '@cloudflare/itty-router-openapi' const default = { schema_version : SchemaVersion.V1 , auth : { type : AuthType . NONE , }, api : { type : APIType . OPENAPI , has_user_authentication : false , url : '/openai.json' , // The path to the schema will be the same as the `openapi_url` field in the router configuration } } Taking into consideration the default values included, we can build a very minimal configuration, assuming the api doesn't require Auth: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter ({ aiPlugin : { name_for_human : 'Cloudflare Radar API' , name_for_model : 'cloudflare_radar' , description_for_human : \"Get data insights from Cloudflare's point of view.\" , description_for_model : \"Plugin for retrieving the data based on Cloudflare Radar's data. Use it whenever a user asks something that might be related to Internet usage, eg. outages, Internet traffic, or Cloudflare Radar's data in particular.\" , contact_email : 'radar@cloudflare.com' , legal_info_url : 'https://www.cloudflare.com/website-terms/' , logo_url : 'https://cdn-icons-png.flaticon.com/512/5969/5969044.png' , }, }) // ... Now when calling the /.well-known/ai-plugin.json path in our worker, we will see a full ai-plugin schema, that automatically points to our generated OpenAPI 3 Schema. Serving the OpenAI schema from multiple domains/hosts \u00b6 When serving from multiple domains, the OpenAPI schema should automatically update to the domain being served. Thats why we made the aiPlugin.api.url to allow relative paths, and when doing so, the itty-router-openapi will automatically fill the domain. import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter ({ aiPlugin : { // other fields api : { url : '/my-schema-for-openai.json' , }, }, }) // ... Then when calling for https://example.com/.well-known/ai-plugin.json the response will have the absolut url { ... api: { url: 'https://example.com/my-schema-for-openai.json' } }","title":"OpenAI plugin support"},{"location":"advanced-user-guide/openai-plugin/#openai-plugin-support","text":"In the aiPlugin field you can define all fields from the plugin manifest This library include default values for the following plugin manifest fields: import { AuthType , SchemaVersion , APIType } from '@cloudflare/itty-router-openapi' const default = { schema_version : SchemaVersion.V1 , auth : { type : AuthType . NONE , }, api : { type : APIType . OPENAPI , has_user_authentication : false , url : '/openai.json' , // The path to the schema will be the same as the `openapi_url` field in the router configuration } } Taking into consideration the default values included, we can build a very minimal configuration, assuming the api doesn't require Auth: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter ({ aiPlugin : { name_for_human : 'Cloudflare Radar API' , name_for_model : 'cloudflare_radar' , description_for_human : \"Get data insights from Cloudflare's point of view.\" , description_for_model : \"Plugin for retrieving the data based on Cloudflare Radar's data. Use it whenever a user asks something that might be related to Internet usage, eg. outages, Internet traffic, or Cloudflare Radar's data in particular.\" , contact_email : 'radar@cloudflare.com' , legal_info_url : 'https://www.cloudflare.com/website-terms/' , logo_url : 'https://cdn-icons-png.flaticon.com/512/5969/5969044.png' , }, }) // ... Now when calling the /.well-known/ai-plugin.json path in our worker, we will see a full ai-plugin schema, that automatically points to our generated OpenAPI 3 Schema.","title":"OpenAI plugin support"},{"location":"advanced-user-guide/openai-plugin/#serving-the-openai-schema-from-multiple-domainshosts","text":"When serving from multiple domains, the OpenAPI schema should automatically update to the domain being served. Thats why we made the aiPlugin.api.url to allow relative paths, and when doing so, the itty-router-openapi will automatically fill the domain. import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter ({ aiPlugin : { // other fields api : { url : '/my-schema-for-openai.json' , }, }, }) // ... Then when calling for https://example.com/.well-known/ai-plugin.json the response will have the absolut url { ... api: { url: 'https://example.com/my-schema-for-openai.json' } }","title":"Serving the OpenAI schema from multiple domains/hosts"},{"location":"advanced-user-guide/openapi-schema-customizations/","text":"OpenAPI schema customizations \u00b6 Besides adding a schema to your endpoints, its also recommended you customize your schema. This can be done by passing the schema argument when creating your router. All OpenAPI Object Properties except paths , components and webhooks are available. paths can only be added by registering routes like: const router = OpenAPIRouter () router . post ( '/scan/metadata/' , ScanMetadataCreate ) components can only be added by registering them in the main router like: const router = OpenAPIRouter () const bearerAuth = router . registry . registerComponent ( 'securitySchemes' , 'bearerAuth' , { type : 'http' , scheme : 'bearer' , bearerFormat : 'JWT' , }, ) Every other property must be defined in your main/root router as such: const router = OpenAPIRouter ({ schema : { info : { title : 'Radar Worker API' , version : '1.0' , }, servers : [ { \"url\" : \"https://development.gigantic-server.com/v1\" , \"description\" : \"Development server\" }, { \"url\" : \"https://staging.gigantic-server.com/v1\" , \"description\" : \"Staging server\" }, { \"url\" : \"https://api.gigantic-server.com/v1\" , \"description\" : \"Production server\" } ] }, }) For more information on the structure of every available property you can read the specification for OpenAPI 3 here and OpenAPI 3.1 here .","title":"OpenAPI schema customizations"},{"location":"advanced-user-guide/openapi-schema-customizations/#openapi-schema-customizations","text":"Besides adding a schema to your endpoints, its also recommended you customize your schema. This can be done by passing the schema argument when creating your router. All OpenAPI Object Properties except paths , components and webhooks are available. paths can only be added by registering routes like: const router = OpenAPIRouter () router . post ( '/scan/metadata/' , ScanMetadataCreate ) components can only be added by registering them in the main router like: const router = OpenAPIRouter () const bearerAuth = router . registry . registerComponent ( 'securitySchemes' , 'bearerAuth' , { type : 'http' , scheme : 'bearer' , bearerFormat : 'JWT' , }, ) Every other property must be defined in your main/root router as such: const router = OpenAPIRouter ({ schema : { info : { title : 'Radar Worker API' , version : '1.0' , }, servers : [ { \"url\" : \"https://development.gigantic-server.com/v1\" , \"description\" : \"Development server\" }, { \"url\" : \"https://staging.gigantic-server.com/v1\" , \"description\" : \"Staging server\" }, { \"url\" : \"https://api.gigantic-server.com/v1\" , \"description\" : \"Production server\" } ] }, }) For more information on the structure of every available property you can read the specification for OpenAPI 3 here and OpenAPI 3.1 here .","title":"OpenAPI schema customizations"},{"location":"advanced-user-guide/reusable-schemas/","text":"Reusable Schemas \u00b6 Before continuing, please learn more about Reusing Descriptions by OpenAPI . To start reusing your schemas, all you need to do is call the .openapi(\"schema name here\") after any schema you have defined. This includes parameters , requestBody , responses even Enum . Note This is only available when using itty-router-openapi types or zod types export class PutMetadata extends OpenAPIRoute { static schema : OpenAPIRouteSchema = { operationId : 'post-bucket-put-object-metadata' , tags : [ 'Buckets' ], summary : 'Update object metadata' , parameters : { bucket : Path ( String ), key : Path ( z . string (). describe ( 'base64 encoded file key' )), }, requestBody : z.object ({ customMetadata : z.record ( z . string (), z . any ()) }). openapi ( \"Object metadata\" ) } // ... } Then when running the server, it would get rendered like this: The OpenAPI spec will also reflect this, by moving the schemas out of the endpoint and into the components : { \"components\" : { \"schemas\" : { \"Object metadata\" : { \"type\" : \"object\" , \"properties\" : { \"customMetadata\" : { \"type\" : \"object\" , \"additionalProperties\" : {} } }, \"required\" : [ \"customMetadata\" ] } } } } Inside the endpoint schema, the reusable parameter is referenced by the name: { \"paths\" : { \"post\" : { \"operationId\" : \"post-bucket-put-object-metadata\" , \"tags\" : [ \"Buckets\" ], \"summary\" : \"Update object metadata\" , \"parameters\" : [], \"requestBody\" : { \"content\" : { \"application/json\" : { \"schema\" : { \"$ref\" : \"#/components/schemas/Object metadata\" } } } }, \"responses\" : {} } } } }","title":"Reusable Schemas"},{"location":"advanced-user-guide/reusable-schemas/#reusable-schemas","text":"Before continuing, please learn more about Reusing Descriptions by OpenAPI . To start reusing your schemas, all you need to do is call the .openapi(\"schema name here\") after any schema you have defined. This includes parameters , requestBody , responses even Enum . Note This is only available when using itty-router-openapi types or zod types export class PutMetadata extends OpenAPIRoute { static schema : OpenAPIRouteSchema = { operationId : 'post-bucket-put-object-metadata' , tags : [ 'Buckets' ], summary : 'Update object metadata' , parameters : { bucket : Path ( String ), key : Path ( z . string (). describe ( 'base64 encoded file key' )), }, requestBody : z.object ({ customMetadata : z.record ( z . string (), z . any ()) }). openapi ( \"Object metadata\" ) } // ... } Then when running the server, it would get rendered like this: The OpenAPI spec will also reflect this, by moving the schemas out of the endpoint and into the components : { \"components\" : { \"schemas\" : { \"Object metadata\" : { \"type\" : \"object\" , \"properties\" : { \"customMetadata\" : { \"type\" : \"object\" , \"additionalProperties\" : {} } }, \"required\" : [ \"customMetadata\" ] } } } } Inside the endpoint schema, the reusable parameter is referenced by the name: { \"paths\" : { \"post\" : { \"operationId\" : \"post-bucket-put-object-metadata\" , \"tags\" : [ \"Buckets\" ], \"summary\" : \"Update object metadata\" , \"parameters\" : [], \"requestBody\" : { \"content\" : { \"application/json\" : { \"schema\" : { \"$ref\" : \"#/components/schemas/Object metadata\" } } } }, \"responses\" : {} } } } }","title":"Reusable Schemas"},{"location":"advanced-user-guide/streaming-responses/","text":"Streaming responses \u00b6 Streaming in itty-router can be done by returning the right set of headers and using a TransformStream . Here's an example for returning a ChatGPT response via streaming, here words are being sent to the client's as soon as the they get generated by the model, instead of waiting for the complete response. import { OpenAPIRoute , OpenAPIRouter , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' import OpenAI from 'openai' export class ChatGPT extends OpenAPIRoute { static schema = { parameters : { question : Query ( z . string ()), }, response : { 200 : { description : 'ChatGPT response' , contentType : 'text/plain' }, }, } async handle ( request : Request , env : any , context : any , data : any ) { const { question } = data . query const { readable , writable } = new TransformStream () const writer = writable . getWriter () const encoder = new TextEncoder () const openai = new OpenAI ({ apiKey : 'your-api-key' , }) const response = await openai . chat . completions . create ({ model : 'gpt-3.5-turbo' , messages : [{ role : 'user' , content : question , }], temperature : 0 , max_tokens : 256 , stream : true , // send this parameter to let openai know they need to stream the response }) const fn = async () => { for await ( const message of response ) { const text = message . choices [ 0 ] ? . delta . content ?? '' await Promise . all ( Array . from ( text ). map ( async ( s ) => { // stream the text chunk await writer . write ( encoder . encode ( s )) // wait a minimum of 20 miliseconds before sending another chunk await new Promise (( res ) => setTimeout ( res , 20 )) }), ) } } // When the response is over, close the write stream fn (). finally ( async () => { await writer . close () }) return new Response ( readable , { headers : { // required headers for streaming responses 'content-type' : 'text/plain; charset=UTF-8' , 'x-content-type-options' : 'nosniff' , 'transfer-encoding' : 'chunked' , }, }) } }","title":"Streaming responses"},{"location":"advanced-user-guide/streaming-responses/#streaming-responses","text":"Streaming in itty-router can be done by returning the right set of headers and using a TransformStream . Here's an example for returning a ChatGPT response via streaming, here words are being sent to the client's as soon as the they get generated by the model, instead of waiting for the complete response. import { OpenAPIRoute , OpenAPIRouter , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' import OpenAI from 'openai' export class ChatGPT extends OpenAPIRoute { static schema = { parameters : { question : Query ( z . string ()), }, response : { 200 : { description : 'ChatGPT response' , contentType : 'text/plain' }, }, } async handle ( request : Request , env : any , context : any , data : any ) { const { question } = data . query const { readable , writable } = new TransformStream () const writer = writable . getWriter () const encoder = new TextEncoder () const openai = new OpenAI ({ apiKey : 'your-api-key' , }) const response = await openai . chat . completions . create ({ model : 'gpt-3.5-turbo' , messages : [{ role : 'user' , content : question , }], temperature : 0 , max_tokens : 256 , stream : true , // send this parameter to let openai know they need to stream the response }) const fn = async () => { for await ( const message of response ) { const text = message . choices [ 0 ] ? . delta . content ?? '' await Promise . all ( Array . from ( text ). map ( async ( s ) => { // stream the text chunk await writer . write ( encoder . encode ( s )) // wait a minimum of 20 miliseconds before sending another chunk await new Promise (( res ) => setTimeout ( res , 20 )) }), ) } } // When the response is over, close the write stream fn (). finally ( async () => { await writer . close () }) return new Response ( readable , { headers : { // required headers for streaming responses 'content-type' : 'text/plain; charset=UTF-8' , 'x-content-type-options' : 'nosniff' , 'transfer-encoding' : 'chunked' , }, }) } }","title":"Streaming responses"},{"location":"user-guide/cors/","text":"CORS support is a feature from itty-router , read more about it here . Here's a quick example for setting up CORS for your endpoints: import { OpenAPIRouter } from \"@cloudflare/itty-router-openapi\" ; import { createCors } from 'itty-router' export const router = OpenAPIRouter (); const { preflight , corsify } = createCors () // embed preflight upstream to handle all OPTIONS requests router . all ( '*' , preflight ) // register the endpoints that will need cors after the previous line router . post ( '/api/auth/register' , AuthRegister ); router . post ( '/api/auth/login' , AuthLogin ); export default { fetch : async ( request , env , ctx ) => { return router . handle ( request , env , ctx ). then ( corsify ) }, };","title":"Cors"},{"location":"user-guide/first-steps/","text":"First, create a new directory, and use wrangler , our command line tool for building Cloudflare Workers, which we assume you have installed already, to initialize the project: mkdir openapi-example && cd openapi-example wrangler init And install itty-router-openapi npm i @cloudflare/itty-router-openapi --save Then in the src/index.ts place this, the smallest router you can have in itty-router-openapi. import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () export default { fetch : router.handle , } Now when running wrangler dev you see server logs wrangler dev \u26c5\ufe0f wrangler 3.4.0 ------------------ wrangler dev now uses local mode by default, powered by \ud83d\udd25 Miniflare and \ud83d\udc77 workerd. To run an edge preview session for your Worker, use wrangler dev --remote \u2394 Starting local server... \u2394 Reloading local server... [mf:inf] Ready on http://127.0.0.1:8787/ [mf:inf] Updated and ready on http://127.0.0.1:8787/ You can now open http://127.0.0.1:8787/docs in your browser to see the Swagger UI, that will hold your future endpoints. // TODO screenshot /docs You can also open the http://127.0.0.1:8787/redocs to see an alternative version with the same endpoints. // TODO screenshot /redocs Creating your first endpoint \u00b6 This is the simplest endpoint you can create, that don't receive any parameters, neither have a response format defined. import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ListEndpoint extends OpenAPIRoute { async handle ( request : Request , env : any , context : any , data : any ) { return [ \"cloudflare\" , \"workers\" ] } } After this you must register the endpoint in the initial router, so your src/index.ts should look something like this: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () router . get ( '/list/' , ListEndpoint ) export default { fetch : router.handle , } Now when opening the /docs you will see your new endpoint and be able to test it right away. // TODO screenshot /docs with endpoint","title":"First steps"},{"location":"user-guide/first-steps/#creating-your-first-endpoint","text":"This is the simplest endpoint you can create, that don't receive any parameters, neither have a response format defined. import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ListEndpoint extends OpenAPIRoute { async handle ( request : Request , env : any , context : any , data : any ) { return [ \"cloudflare\" , \"workers\" ] } } After this you must register the endpoint in the initial router, so your src/index.ts should look something like this: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () router . get ( '/list/' , ListEndpoint ) export default { fetch : router.handle , } Now when opening the /docs you will see your new endpoint and be able to test it right away. // TODO screenshot /docs with endpoint","title":"Creating your first endpoint"},{"location":"user-guide/middleware/","text":"Currently middleware support is still limited to what itty-router has to offer read more about it here . Due to this, you cannot access the validated data parameter in your middlewares. However there are plans to offer this in the future. In short, an itty-router middleware is a function that doesn't return anything. With this in mind, everything can be a middleware and every change you make in the request , env and context will be passed to endpoint downstream. Here is a simple authentication middleware as an example of what you can do currently: export function getBearer ( request : Request ) : null | string { const authHeader = request . headers . get ( 'Authorization' ) if ( ! authHeader || authHeader . substring ( 0 , 6 ) !== 'Bearer' ) { return null } return authHeader . substring ( 6 ). trim () } export async function authenticateUser ( request : Request , env : any , context : any ) { const token = getBearer ( request ) let session if ( token ) { // Implement your own token validation here session = validateToken ( token ) } if ( ! token || ! session ) { return Response . json ({ success : false , errors : \"Authentication error\" }, { status : 401 , }) } // set the user_id for endpoint routes to be able to reference it env . user_id = session . user_id } When registering the middleware you have to take into consideration that only endpoint registered after the middleware will be affected by it, here is an example on how you would register the authentication middleware above export const router = OpenAPIRouter () // 1. Endpoints that don't require Auth router . post ( '/api/auth/register' , AuthRegister ); router . post ( '/api/auth/login' , AuthLogin ); // 2. Authentication middleware router . all ( '/api/*' , authenticateUser ) // 3. Endpoints that require Auth router . get ( \"/api/search\" , GetSearch );","title":"Middleware"},{"location":"user-guide/migrating-from-itty-router/","text":"Migrating existing itty-router applications \u00b6 All it takes is changing one line of code. After installing itty-router-openapi replace Router with the new OpenAPIRouter function. // Old router //import { Router } from 'itty-router' //const router = Router() // New router import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () // Old routes remain the same router . get ( '/todos' , () => new Response ( 'Todos Index!' )) router . get ( '/todos/:id' , ({ params }) => new Response ( `Todo # ${ params . id } ` )) // ... Now, when running the application, go to /docs . You will see your endpoints listed with the Path parameters automatically parsed and ready to be invoked.","title":"Migrating existing itty-router applications"},{"location":"user-guide/migrating-from-itty-router/#migrating-existing-itty-router-applications","text":"All it takes is changing one line of code. After installing itty-router-openapi replace Router with the new OpenAPIRouter function. // Old router //import { Router } from 'itty-router' //const router = Router() // New router import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () // Old routes remain the same router . get ( '/todos' , () => new Response ( 'Todos Index!' )) router . get ( '/todos/:id' , ({ params }) => new Response ( `Todo # ${ params . id } ` )) // ... Now, when running the application, go to /docs . You will see your endpoints listed with the Path parameters automatically parsed and ready to be invoked.","title":"Migrating existing itty-router applications"},{"location":"user-guide/nested-routers/","text":"For big projects, having all routes in the same file can be chaotic. In this example we split some routes to a different router // api/attacks/router.ts import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' export const attacksRouter = OpenAPIRouter ({ base : '/api/v1/attacks' }) attacksRouter . get ( '/layer3/timeseries' , AttacksLayer3Timeseries ) // router.ts import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { attacksRouter } from 'api/attacks/router' export const router = OpenAPIRouter ({ schema : { info : { title : 'Radar Worker API' , version : '1.0' , }, }, }) router . all ( '/api/v1/attacks/*' , attacksRouter ) // Other routes router . get ( '/api/v1/bgp/timeseries' , BgpTimeseries ) Now run wrangler dev and go to /docs with your browser, here you can verify that all nested routers appear correctly and you are able to call every endpoint.","title":"Nested routers"},{"location":"user-guide/path-parameters/","text":"Please make sure to read the Types page before continuing. You can declare Path parameters in the parameters property of your endpoint schema. The validated data is available under data.params.<name> , where name is the key used inside the parameters property. Basic parameter \u00b6 For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. import { OpenAPIRoute , Path , Int } from '@cloudflare/itty-router-openapi' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : Path ( Int , { description : 'ToDo ID' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { todoId } = data . params // ... } } Then remember to register the endpoint with the parameter name in the url starting with : router . get ( '/todos/:todoId' , ToDoFetch ) Advanced parameters \u00b6 If you need a more advanced control over the validation, you should use Zod . Here is an example that allows only number lower than 10 in the path import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : Path ( z . coerce . number (). lt ( 10 ), { description : 'ToDo ID' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { todoId } = data . params // ... } } Reusable parameters \u00b6 While you can define a variable with your parameter and then reference it in more than 1 endpoint, you will notice that you have to repeat the parameter name in all endpoints. import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const pathTodoId = Path ( z . coerce . number (). lt ( 10 ), { description : 'ToDo ID' , }) export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : pathTodoId , }, } // ... } But if you need a parameter in more than a dozen endpoints, it can be tricky to make sure all have the same name. With this in mind we added support for you to define parameter in an array instead of an object, this way, you define the name you want the parameter to have in the variable and then reuse it everywhere: import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const pathTodoId = Path ( z . coerce . number (). lt ( 10 ), { name : 'todoId' , description : 'ToDo ID' , }) export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : [ pathTodoId , ], } // ... }","title":"Path parameters"},{"location":"user-guide/path-parameters/#basic-parameter","text":"For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. import { OpenAPIRoute , Path , Int } from '@cloudflare/itty-router-openapi' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : Path ( Int , { description : 'ToDo ID' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { todoId } = data . params // ... } } Then remember to register the endpoint with the parameter name in the url starting with : router . get ( '/todos/:todoId' , ToDoFetch )","title":"Basic parameter"},{"location":"user-guide/path-parameters/#advanced-parameters","text":"If you need a more advanced control over the validation, you should use Zod . Here is an example that allows only number lower than 10 in the path import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : Path ( z . coerce . number (). lt ( 10 ), { description : 'ToDo ID' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { todoId } = data . params // ... } }","title":"Advanced parameters"},{"location":"user-guide/path-parameters/#reusable-parameters","text":"While you can define a variable with your parameter and then reference it in more than 1 endpoint, you will notice that you have to repeat the parameter name in all endpoints. import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const pathTodoId = Path ( z . coerce . number (). lt ( 10 ), { description : 'ToDo ID' , }) export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : pathTodoId , }, } // ... } But if you need a parameter in more than a dozen endpoints, it can be tricky to make sure all have the same name. With this in mind we added support for you to define parameter in an array instead of an object, this way, you define the name you want the parameter to have in the variable and then reuse it everywhere: import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const pathTodoId = Path ( z . coerce . number (). lt ( 10 ), { name : 'todoId' , description : 'ToDo ID' , }) export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : [ pathTodoId , ], } // ... }","title":"Reusable parameters"},{"location":"user-guide/query-parameters/","text":"Please make sure to read the Types page before continuing. You can declare Query parameters in the parameters property of your endpoint schema. The validated data is available under data.query.<name> , where name is the key used inside the parameters property. Basic parameter \u00b6 For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. import { OpenAPIRoute , Query , Int } from '@cloudflare/itty-router-openapi' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { limit : Query ( Int , { description : 'Number of results to return' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } } Advanced parameters \u00b6 If you need a more advanced control over the validation, you should use Zod . While the previous example will work well, you might want more control, like make the limit something between 10 and 100. import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'List ToDos' , parameters : { limit : Query ( z . coerce . number (). gte ( 10 ). lte ( 100 ), { description : 'Number of results to return' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } } Reusable parameters \u00b6 While you can define a variable with your parameter and then reference it in more than 1 endpoint, you will notice that you have to repeat the parameter name in all endpoints. import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const queryLimit = Query ( z . coerce . number (). gte ( 10 ). lte ( 100 ), { description : 'Number of results to return' , }) export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'List ToDos' , parameters : { limit : queryLimit , }, } // ... } But if you need a parameter in more than a dozen endpoints, it can be tricky to make sure all have the same name. With this in mind we added support for you to define parameter in an array instead of an object, this way, you define the name you want the parameter to have in the variable and then reuse it everywhere: import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const queryLimit = Query ( z . coerce . number (). gte ( 10 ). lte ( 100 ), { name : 'limit' , description : 'Number of results to return' , }) export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'List ToDos' , parameters : [ queryLimit , ], } // ... }","title":"Query parameters"},{"location":"user-guide/query-parameters/#basic-parameter","text":"For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. import { OpenAPIRoute , Query , Int } from '@cloudflare/itty-router-openapi' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { limit : Query ( Int , { description : 'Number of results to return' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } }","title":"Basic parameter"},{"location":"user-guide/query-parameters/#advanced-parameters","text":"If you need a more advanced control over the validation, you should use Zod . While the previous example will work well, you might want more control, like make the limit something between 10 and 100. import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'List ToDos' , parameters : { limit : Query ( z . coerce . number (). gte ( 10 ). lte ( 100 ), { description : 'Number of results to return' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } }","title":"Advanced parameters"},{"location":"user-guide/query-parameters/#reusable-parameters","text":"While you can define a variable with your parameter and then reference it in more than 1 endpoint, you will notice that you have to repeat the parameter name in all endpoints. import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const queryLimit = Query ( z . coerce . number (). gte ( 10 ). lte ( 100 ), { description : 'Number of results to return' , }) export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'List ToDos' , parameters : { limit : queryLimit , }, } // ... } But if you need a parameter in more than a dozen endpoints, it can be tricky to make sure all have the same name. With this in mind we added support for you to define parameter in an array instead of an object, this way, you define the name you want the parameter to have in the variable and then reuse it everywhere: import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const queryLimit = Query ( z . coerce . number (). gte ( 10 ). lte ( 100 ), { name : 'limit' , description : 'Number of results to return' , }) export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'List ToDos' , parameters : [ queryLimit , ], } // ... }","title":"Reusable parameters"},{"location":"user-guide/request-body/","text":"Please make sure to read the Types page before continuing. You can declare Body Requests in the requestBody property of your endpoint schema. The validated data is available under data.body.<name> , where name is the key used inside the requestBody property. For nested objects the validated data will be under the same position as defined, for example data.body.task.name . Basic parameter \u00b6 For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. Defining a schema using native types is as simple as defining a without any special parameters. In this example we are defining a object with an optional description and an array of strings steps . import { OpenAPIRoute , Query , Str } from '@cloudflare/itty-router-openapi' export class ToDoCreate extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Create a ToDo' , requestBody : { name : String , description : new Str ({ required : false }), steps : [ new Str ({ example : 'open the door' })] } } async handle ( request : Request , env : any , context : any , data : any ) { const newToDo = data . body // ... } } Advanced parameters \u00b6 If you need a more advanced control over the validation, you should use Zod . Zod types can be used inside itty-router-openapi native types! While the previous example will work well, you might want more control, like make the description a string or an array of strings. import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoCreate extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Create a ToDo' , requestBody : { name : String , description : z.string (). or ( z . string (). array ()), steps : [ new Str ({ example : 'open the door' })] } } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } } Or you can define the exact same request body as above all in Zod import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoCreate extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Create a ToDo' , requestBody : z.object ({ name : z.string (), description : z.string (). or ( z . string (). array ()), steps : z.string (). array () }) } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } }","title":"Request body"},{"location":"user-guide/request-body/#basic-parameter","text":"For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. Defining a schema using native types is as simple as defining a without any special parameters. In this example we are defining a object with an optional description and an array of strings steps . import { OpenAPIRoute , Query , Str } from '@cloudflare/itty-router-openapi' export class ToDoCreate extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Create a ToDo' , requestBody : { name : String , description : new Str ({ required : false }), steps : [ new Str ({ example : 'open the door' })] } } async handle ( request : Request , env : any , context : any , data : any ) { const newToDo = data . body // ... } }","title":"Basic parameter"},{"location":"user-guide/request-body/#advanced-parameters","text":"If you need a more advanced control over the validation, you should use Zod . Zod types can be used inside itty-router-openapi native types! While the previous example will work well, you might want more control, like make the description a string or an array of strings. import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoCreate extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Create a ToDo' , requestBody : { name : String , description : z.string (). or ( z . string (). array ()), steps : [ new Str ({ example : 'open the door' })] } } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } } Or you can define the exact same request body as above all in Zod import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoCreate extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Create a ToDo' , requestBody : z.object ({ name : z.string (), description : z.string (). or ( z . string (). array ()), steps : z.string (). array () }) } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } }","title":"Advanced parameters"},{"location":"user-guide/response-format/","text":"Please make sure to read the Types page before continuing. As said in the Types page, you can define response schemas using Native types or Zod types. But the easier way for this is to just define it using javascript variables, or copy paste your endpoints response after calling it. Here's an example of a response schema using variables import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class TimeseriesFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , responses : { '200' : { description : 'Timeseries response' , schema : { series : { timestamps : [ '2023-01-01 00:00:00' ], values : [ 0.56 ], }, }, }, }, } // ... } And because this is all common javascript objects you can reuse your schemas like: import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' const annotations = [ { 'dataSource' : 'NET' , 'startDate' : '2023-08-11T10:00:00Z' , 'endDate' : '2023-08-11T10:30:00Z' , 'eventType' : 'PIPELINE' , 'description' : 'Internal issue' , 'linkedUrl' : '' , 'isInstantaneous' : false , }, ] export class TimeseriesFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , responses : { '200' : { description : 'Timeseries with meta response' , schema : { meta : { annotations : annotations }, series : { timestamps : [ '2023-01-01 00:00:00' ], values : [ 0.56 ], }, }, }, }, } // ... } You can also define other response formats than application/json read more here .","title":"Response format"},{"location":"user-guide/router-options/","text":"OpenAPIRouter(options = {}) \u00b6 Name Type(s) Description Examples base string prefixes all routes with this string Router({ base: '/api' }) routes array of routes array of manual routes for preloading see documentation schema object Object of the common OpenAPI customizations see documentation docs_url string or null or undefined Path for swagger docs, null : disabled, undefined : /docs /docs redoc_url string or null or undefined Path for redoc docs, null : disabled, undefined : /redocs /redocs openapi_url string or null or undefined Path for openapi schema, null : disabled, undefined : /openapi.json /openapi.json raiseUnknownParameters boolean This will raise validation errors when an endpoint received an unknown query parameter true skipValidation boolean This will skip request data validation false generateOperationIds boolean This will generate operation ids from class names for your endpoints when nothing is provided true openapiVersion string Use this property to switch between the 3 and 3.1 OpenAPI specification, by default this will be 3.1 3.1 aiPlugin object or undefined Object that will be used to generate the ai-plugin.json schema see schema bellow aiPlugin \u00b6 Example configurations are available here Name Type(s) Description Examples schema_version SchemaVersion or string or undefined Schema Version, undefined : defaults v1 v1 name_for_model string Name for model cloudflare_radar name_for_human string Name for Human Cloudflare Radar API description_for_model string Description for model Plugin for retrieving the data based on Cloudflare Radar's data. Use it whenever a user asks something that might be related to Internet usage, eg. outages, Internet traffic, or Cloudflare Radar's data in particular. description_for_human string Description for human Get data insights from Cloudflare's point of view. logo_url string Logo url https://cdn-icons-png.flaticon.com/512/5969/5969044.png contact_email string Contact email radar@cloudflare.com legal_info_url string Legal info url https://www.cloudflare.com/website-terms/ auth object or undefined Object for Auth configuration, undefined : defaults to no Auth {type: AuthType.USER_HTTP, authorization_type: 'bearer'} api object or undefined Object for Api configuration, undefined : defaults to openapi.json spec {type: APIType.OPENAPI, has_user_authentication: false, url: '/openai.json'} Selecting a different OpenAPI version \u00b6 By default itty-router-openapi generated OpenAPI 3.1 schemas, but you can revert back to 3.0 by updating your router configuration const router = OpenAPIRouter ({ openapiVersion : '3' , })","title":"Router options"},{"location":"user-guide/router-options/#openapirouteroptions","text":"Name Type(s) Description Examples base string prefixes all routes with this string Router({ base: '/api' }) routes array of routes array of manual routes for preloading see documentation schema object Object of the common OpenAPI customizations see documentation docs_url string or null or undefined Path for swagger docs, null : disabled, undefined : /docs /docs redoc_url string or null or undefined Path for redoc docs, null : disabled, undefined : /redocs /redocs openapi_url string or null or undefined Path for openapi schema, null : disabled, undefined : /openapi.json /openapi.json raiseUnknownParameters boolean This will raise validation errors when an endpoint received an unknown query parameter true skipValidation boolean This will skip request data validation false generateOperationIds boolean This will generate operation ids from class names for your endpoints when nothing is provided true openapiVersion string Use this property to switch between the 3 and 3.1 OpenAPI specification, by default this will be 3.1 3.1 aiPlugin object or undefined Object that will be used to generate the ai-plugin.json schema see schema bellow","title":"OpenAPIRouter(options = {})"},{"location":"user-guide/router-options/#aiplugin","text":"Example configurations are available here Name Type(s) Description Examples schema_version SchemaVersion or string or undefined Schema Version, undefined : defaults v1 v1 name_for_model string Name for model cloudflare_radar name_for_human string Name for Human Cloudflare Radar API description_for_model string Description for model Plugin for retrieving the data based on Cloudflare Radar's data. Use it whenever a user asks something that might be related to Internet usage, eg. outages, Internet traffic, or Cloudflare Radar's data in particular. description_for_human string Description for human Get data insights from Cloudflare's point of view. logo_url string Logo url https://cdn-icons-png.flaticon.com/512/5969/5969044.png contact_email string Contact email radar@cloudflare.com legal_info_url string Legal info url https://www.cloudflare.com/website-terms/ auth object or undefined Object for Auth configuration, undefined : defaults to no Auth {type: AuthType.USER_HTTP, authorization_type: 'bearer'} api object or undefined Object for Api configuration, undefined : defaults to openapi.json spec {type: APIType.OPENAPI, has_user_authentication: false, url: '/openai.json'}","title":"aiPlugin"},{"location":"user-guide/router-options/#selecting-a-different-openapi-version","text":"By default itty-router-openapi generated OpenAPI 3.1 schemas, but you can revert back to 3.0 by updating your router configuration const router = OpenAPIRouter ({ openapiVersion : '3' , })","title":"Selecting a different OpenAPI version"},{"location":"user-guide/security/","text":"For this page you must have some knowledge of how security works in OpenAPI, read more here . Please notice that currently security in itty-router-openapi is only for schema generation, if you want to add some kind of authentication, please read more in the middleware page ! Register the security component \u00b6 The first step into security is to register your security component in your main router. Here's a simple Bearer token example: const router = OpenAPIRouter () router . registry . registerComponent ( 'securitySchemes' , 'BearerAuth' , { type : http , scheme : bearer , }, ) From this point onward you can either make all endpoints require security or apply the security requirement only in some endpoints. All endpoints require security \u00b6 For this add the security component to your main router schema customization field Notice that the key used in security must be the same used to register the component const router = OpenAPIRouter ({ schema : { security : [ { BearerAuth : [], }, ], }, }) router . registry . registerComponent ( 'securitySchemes' , 'BearerAuth' , { type : http , scheme : bearer , }, ) Some endpoints require security \u00b6 For this add the security component to your main endpoint schema customization field Notice that the key used in security must be the same used to register the component export class ScanMetadataCreate extends OpenAPIRoute { static schema : OpenAPIRouteSchema = { tags : [ 'Scans' ], summary : 'Create Scan metadata' , requestBody : { scan_id : Uuid , url : z.string (). url (), destination_ip : z.string (). ip (), timestamp : z.string (). datetime (), console_logs : [ z . string ()], }, security : [ { bearerAuth : [], }, ], } // ... } const router = OpenAPIRouter () router . registry . registerComponent ( 'securitySchemes' , 'BearerAuth' , { type : http , scheme : bearer , }, ) router . post ( '/scan/metadata/' , ScanMetadataCreate ) For more informations on how to setup security read the OpenAPI spec here .","title":"Security"},{"location":"user-guide/security/#register-the-security-component","text":"The first step into security is to register your security component in your main router. Here's a simple Bearer token example: const router = OpenAPIRouter () router . registry . registerComponent ( 'securitySchemes' , 'BearerAuth' , { type : http , scheme : bearer , }, ) From this point onward you can either make all endpoints require security or apply the security requirement only in some endpoints.","title":"Register the security component"},{"location":"user-guide/security/#all-endpoints-require-security","text":"For this add the security component to your main router schema customization field Notice that the key used in security must be the same used to register the component const router = OpenAPIRouter ({ schema : { security : [ { BearerAuth : [], }, ], }, }) router . registry . registerComponent ( 'securitySchemes' , 'BearerAuth' , { type : http , scheme : bearer , }, )","title":"All endpoints require security"},{"location":"user-guide/security/#some-endpoints-require-security","text":"For this add the security component to your main endpoint schema customization field Notice that the key used in security must be the same used to register the component export class ScanMetadataCreate extends OpenAPIRoute { static schema : OpenAPIRouteSchema = { tags : [ 'Scans' ], summary : 'Create Scan metadata' , requestBody : { scan_id : Uuid , url : z.string (). url (), destination_ip : z.string (). ip (), timestamp : z.string (). datetime (), console_logs : [ z . string ()], }, security : [ { bearerAuth : [], }, ], } // ... } const router = OpenAPIRouter () router . registry . registerComponent ( 'securitySchemes' , 'BearerAuth' , { type : http , scheme : bearer , }, ) router . post ( '/scan/metadata/' , ScanMetadataCreate ) For more informations on how to setup security read the OpenAPI spec here .","title":"Some endpoints require security"}]}