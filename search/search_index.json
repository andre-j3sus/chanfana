{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"itty-router-openapi \u00b6 OpenAPI 3 and 3.1 schema generator and validator for Cloudflare Workers Documentation : https://cloudflare.github.io/itty-router-openapi/ Source Code : https://github.com/cloudflare/itty-router-openapi/ itty-router-openapi is a library that extends itty-router , a powerful and lightweight routing system for Cloudflare Workers, already familiar to many developers, and adds an easy-to-use and compact OpenAPI 3 and 3.1 schema generator and validator. itty-route-openapi can also have class-based routes, allowing the developer to quickly build on top of and extend other endpoints while reusing code. The key features are: OpenAPI 3 and 3.1 schema generator Query , Path , Request Body and Header validator Fully written in typescript Class-based endpoints Out of the box OpenAI plugin support Drop-in replacement for existing itty-router applications A template repository is available at cloudflare/workers-sdk , with a live demo here . Why create another router library for workers? \u00b6 This framework built on top of itty-router and extends some of its core features, such as adding class-based endpoints. It also provides a simple and iterative path for migrating from old applications based on itty-router . Building APIs and maintaining good documentation on the parameters and fields of your API hard. However, there is an open standard that makes this documentation process much more effortless, called OpenAPI . OpenAPI \"defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.\" This allows other machines to reliably parse those definitions and use the remote APIs easily, without additional implementation logic. Some of the top requirements for Radar 2.0 were having better API documentation, improving the deployment lifecycle with end-to-end testing, and making it publicly available to Cloudflare customers. OpenAPI support quickly jumped out as the obvious choice to help us on all these fronts. However, we struggled to find an existing OpenAPI framework that checked all our boxes: Easy integration with Cloudflare Workers Input validation for endpoints parameters Actual code-based schema generation (not just generated from comments or manually) Since we couldn't find anything that suited us, as many engineers do, we opted for the second-best alternative: building our own and open-source it. Installation \u00b6 First, create a new directory, and use wrangler , our command line tool for building Cloudflare Workers, which we assume you have installed already, to initialize the project: mkdir openapi-example && cd openapi-example wrangler init Now install itty-router-openapi : npm i @cloudflare/itty-router-openapi --save Example \u00b6 Let's create our first class-based endpoint called TaskFetch in src/tasks.ts now. Make sure that \u2018Task' is global, otherwise you must redefine responses.schema.task with every endpoint. When defining the schema, you can interchangeably use native typescript types or use the included types to set required flags, descriptions, and other fields. import { DateOnly , OpenAPIRoute , Path , Str , OpenAPIRouter } from '@cloudflare/itty-router-openapi' export class TaskFetch extends OpenAPIRoute { static schema = { tags : [ 'Tasks' ], summary : 'Get a single Task by slug' , parameters : { taskSlug : Path ( Str , { description : 'Task slug' , }), }, responses : { '200' : { schema : { metaData : {}, task : { name : new Str ({ example : 'lorem' }), slug : String , description : new Str ({ required : false }), completed : Boolean , due_date : new DateOnly (), }, }, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // Retrieve the validated slug const { taskSlug } = data // Actually fetch a task using the taskSlug return { metaData : { meta : 'data' }, task : { name : 'my task' , slug : taskSlug , description : 'this needs to be done' , completed : false , due_date : new Date (). toISOString (). slice ( 0 , 10 ), }, } } } const router = OpenAPIRouter () router . get ( '/api/tasks/:taskSlug/' , TaskFetch ) // 404 for everything else router . all ( '*' , () => new Response ( 'Not Found.' , { status : 404 })) export default { fetch : router.handle , } Now initialize a new OpenAPIRouter, and reference our newly created endpoint as a regular \u2018itty-router\u2019 .get route: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { TaskFetch } from './tasks' Finally, run wrangler dev and head to /docs our /redocs with your browser. You'll be greeted with a beautiful OpenAPI page that you can use to test and call your new endpoint. Pretty easy, right? Feedback and contributions \u00b6 itty-router-openapi aims to be at the core of new APIs built using Workers and define a pattern to allow everyone to have an OpenAPI-compliant schema without worrying about implementation details or reinventing the wheel. itty-router-openapi is considered stable and production ready and is being used with the Radar 2.0 public API . Currently this package is maintained by the Cloudflare Radar Team and features are prioritized based on the Radar roadmap. Nonetheless you can still open pull requests or issues in this repository and they will get reviewed. You can also talk to us in the Cloudflare Community or the Radar Discord Channel","title":"itty-router-openapi"},{"location":"#itty-router-openapi","text":"OpenAPI 3 and 3.1 schema generator and validator for Cloudflare Workers Documentation : https://cloudflare.github.io/itty-router-openapi/ Source Code : https://github.com/cloudflare/itty-router-openapi/ itty-router-openapi is a library that extends itty-router , a powerful and lightweight routing system for Cloudflare Workers, already familiar to many developers, and adds an easy-to-use and compact OpenAPI 3 and 3.1 schema generator and validator. itty-route-openapi can also have class-based routes, allowing the developer to quickly build on top of and extend other endpoints while reusing code. The key features are: OpenAPI 3 and 3.1 schema generator Query , Path , Request Body and Header validator Fully written in typescript Class-based endpoints Out of the box OpenAI plugin support Drop-in replacement for existing itty-router applications A template repository is available at cloudflare/workers-sdk , with a live demo here .","title":"itty-router-openapi"},{"location":"#why-create-another-router-library-for-workers","text":"This framework built on top of itty-router and extends some of its core features, such as adding class-based endpoints. It also provides a simple and iterative path for migrating from old applications based on itty-router . Building APIs and maintaining good documentation on the parameters and fields of your API hard. However, there is an open standard that makes this documentation process much more effortless, called OpenAPI . OpenAPI \"defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.\" This allows other machines to reliably parse those definitions and use the remote APIs easily, without additional implementation logic. Some of the top requirements for Radar 2.0 were having better API documentation, improving the deployment lifecycle with end-to-end testing, and making it publicly available to Cloudflare customers. OpenAPI support quickly jumped out as the obvious choice to help us on all these fronts. However, we struggled to find an existing OpenAPI framework that checked all our boxes: Easy integration with Cloudflare Workers Input validation for endpoints parameters Actual code-based schema generation (not just generated from comments or manually) Since we couldn't find anything that suited us, as many engineers do, we opted for the second-best alternative: building our own and open-source it.","title":"Why create another router library for workers?"},{"location":"#installation","text":"First, create a new directory, and use wrangler , our command line tool for building Cloudflare Workers, which we assume you have installed already, to initialize the project: mkdir openapi-example && cd openapi-example wrangler init Now install itty-router-openapi : npm i @cloudflare/itty-router-openapi --save","title":"Installation"},{"location":"#example","text":"Let's create our first class-based endpoint called TaskFetch in src/tasks.ts now. Make sure that \u2018Task' is global, otherwise you must redefine responses.schema.task with every endpoint. When defining the schema, you can interchangeably use native typescript types or use the included types to set required flags, descriptions, and other fields. import { DateOnly , OpenAPIRoute , Path , Str , OpenAPIRouter } from '@cloudflare/itty-router-openapi' export class TaskFetch extends OpenAPIRoute { static schema = { tags : [ 'Tasks' ], summary : 'Get a single Task by slug' , parameters : { taskSlug : Path ( Str , { description : 'Task slug' , }), }, responses : { '200' : { schema : { metaData : {}, task : { name : new Str ({ example : 'lorem' }), slug : String , description : new Str ({ required : false }), completed : Boolean , due_date : new DateOnly (), }, }, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // Retrieve the validated slug const { taskSlug } = data // Actually fetch a task using the taskSlug return { metaData : { meta : 'data' }, task : { name : 'my task' , slug : taskSlug , description : 'this needs to be done' , completed : false , due_date : new Date (). toISOString (). slice ( 0 , 10 ), }, } } } const router = OpenAPIRouter () router . get ( '/api/tasks/:taskSlug/' , TaskFetch ) // 404 for everything else router . all ( '*' , () => new Response ( 'Not Found.' , { status : 404 })) export default { fetch : router.handle , } Now initialize a new OpenAPIRouter, and reference our newly created endpoint as a regular \u2018itty-router\u2019 .get route: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { TaskFetch } from './tasks' Finally, run wrangler dev and head to /docs our /redocs with your browser. You'll be greeted with a beautiful OpenAPI page that you can use to test and call your new endpoint. Pretty easy, right?","title":"Example"},{"location":"#feedback-and-contributions","text":"itty-router-openapi aims to be at the core of new APIs built using Workers and define a pattern to allow everyone to have an OpenAPI-compliant schema without worrying about implementation details or reinventing the wheel. itty-router-openapi is considered stable and production ready and is being used with the Radar 2.0 public API . Currently this package is maintained by the Cloudflare Radar Team and features are prioritized based on the Radar roadmap. Nonetheless you can still open pull requests or issues in this repository and they will get reviewed. You can also talk to us in the Cloudflare Community or the Radar Discord Channel","title":"Feedback and contributions"},{"location":"migrating-from-itty-router/","text":"Migrating existing itty-router applications \u00b6 All it takes is changing one line of code. After installing itty-router-openapi replace Router with the new OpenAPIRouter function. // Old router //import { Router } from 'itty-router' //const router = Router() // New router import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () // Old routes remain the same router . get ( '/todos' , () => new Response ( 'Todos Index!' )) router . get ( '/todos/:id' , ({ params }) => new Response ( `Todo # ${ params . id } ` )) // ... Now, when running the application, go to /docs . You will see your endpoints listed with the Path parameters automatically parsed and ready to be invoked.","title":"Migrating existing itty-router applications"},{"location":"migrating-from-itty-router/#migrating-existing-itty-router-applications","text":"All it takes is changing one line of code. After installing itty-router-openapi replace Router with the new OpenAPIRouter function. // Old router //import { Router } from 'itty-router' //const router = Router() // New router import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () // Old routes remain the same router . get ( '/todos' , () => new Response ( 'Todos Index!' )) router . get ( '/todos/:id' , ({ params }) => new Response ( `Todo # ${ params . id } ` )) // ... Now, when running the application, go to /docs . You will see your endpoints listed with the Path parameters automatically parsed and ready to be invoked.","title":"Migrating existing itty-router applications"},{"location":"types/","text":"Types are used everywhere in this framework, from defining parameters to response formats. There are 2 API's to define types in itty-router-open, but we recommend that you choose one and stick to it. Native types, are types developed exclusive to this framework, they are pretty straight forward and easy to use, but are some limitations. Zod types, are as the name says, types from the Zod library, they are much more verbose than the native types, but allows you to define almost everything. Native types \u00b6 All of theses Types can be imported like: import { Email } from '@cloudflare/itty-router-openapi' Name Arguments Num description example default Int description example default Str description example default format Enumeration description example default values enumCaseSensitive DateTime description example default DateOnly description example default Bool description example default Regex description example default pattern patternError Email description example default Uuid description example default Hostname description example default Ipv4 description example default Ipv6 description example default As an example, you would define a string query parameter as the following: import { Query , Str } from '@cloudflare/itty-router-openapi' const queryDescription = Query ( Str , { description : 'Task description' }) Then use it in a endpoint like this: import { Query , Str , Int , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class Example extends OpenAPIRoute { static schema = { parameters : { description : queryDescription , }, responses : { '200' : { schema : {}, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { return { validatedDescription : data.query.description } } } Zod types \u00b6 Zod is a TypeScript-first schema declaration and validation library. I'm using the term \"schema\" to broadly refer to any data type, from a simple string to a complex nested object. Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator once and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures. Zod types can be used everywhere the Native types are used (because native types are actually just Zod wrappers). Zod allows you to have a much more granular control over what is a valid input or not. For example you could define a Query parameter that only accepts number bellow or equal to 10 with the following line. import { Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const queryResponseLimit = Query ( z . coerce . number (). lte ( 10 )) Then use it in a endpoint like this: import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class Example extends OpenAPIRoute { static schema = { parameters : { limit : queryResponseLimit , }, responses : { '200' : { schema : {}, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { return { validatedLimit : data.query.limit } } } Read the Zod documentation here !","title":"Types"},{"location":"types/#native-types","text":"All of theses Types can be imported like: import { Email } from '@cloudflare/itty-router-openapi' Name Arguments Num description example default Int description example default Str description example default format Enumeration description example default values enumCaseSensitive DateTime description example default DateOnly description example default Bool description example default Regex description example default pattern patternError Email description example default Uuid description example default Hostname description example default Ipv4 description example default Ipv6 description example default As an example, you would define a string query parameter as the following: import { Query , Str } from '@cloudflare/itty-router-openapi' const queryDescription = Query ( Str , { description : 'Task description' }) Then use it in a endpoint like this: import { Query , Str , Int , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class Example extends OpenAPIRoute { static schema = { parameters : { description : queryDescription , }, responses : { '200' : { schema : {}, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { return { validatedDescription : data.query.description } } }","title":"Native types"},{"location":"types/#zod-types","text":"Zod is a TypeScript-first schema declaration and validation library. I'm using the term \"schema\" to broadly refer to any data type, from a simple string to a complex nested object. Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator once and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures. Zod types can be used everywhere the Native types are used (because native types are actually just Zod wrappers). Zod allows you to have a much more granular control over what is a valid input or not. For example you could define a Query parameter that only accepts number bellow or equal to 10 with the following line. import { Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' const queryResponseLimit = Query ( z . coerce . number (). lte ( 10 )) Then use it in a endpoint like this: import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class Example extends OpenAPIRoute { static schema = { parameters : { limit : queryResponseLimit , }, responses : { '200' : { schema : {}, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { return { validatedLimit : data.query.limit } } } Read the Zod documentation here !","title":"Zod types"},{"location":"advanced-user-guide/ci-cd-pipelines/","text":"CI/CD \u00b6 For CI/CD pipelines, you can read the complete openapi.json schemas by calling the schema property from the router instance. Here is an example of a nodejs script that would pick the schema, make some changes and write it to a file, to be able to be picked from a CI/CD pipeline. import fs from 'fs' import { router } from '../src/router' // Get the Schema from itty-router-openapi const schema = router . schema // Optionaly: update the schema with some costumizations for publishing // Write the final schema fs . writeFileSync ( './public-api.json' , JSON . stringify ( schema , null , 2 ))","title":"CI/CD"},{"location":"advanced-user-guide/ci-cd-pipelines/#cicd","text":"For CI/CD pipelines, you can read the complete openapi.json schemas by calling the schema property from the router instance. Here is an example of a nodejs script that would pick the schema, make some changes and write it to a file, to be able to be picked from a CI/CD pipeline. import fs from 'fs' import { router } from '../src/router' // Get the Schema from itty-router-openapi const schema = router . schema // Optionaly: update the schema with some costumizations for publishing // Write the final schema fs . writeFileSync ( './public-api.json' , JSON . stringify ( schema , null , 2 ))","title":"CI/CD"},{"location":"advanced-user-guide/custom-response-formats/","text":"Describing a binary file: \u00b6 import { OpenAPIRoute , Str } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { summary : 'My summary of a custom pdf file endpoint.' , responses : { '200' : { contentType : 'application/pdf' , schema : new Str ({ format : 'binary' }), }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // ... } } Describing a XML response: \u00b6 import { OpenAPIRoute , Str } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { summary : 'My summary of a custom pdf file endpoint.' , responses : { '200' : { contentType : 'application/xml' , schema : new Obj ( { code : new Str ({ example : '13335' }), name : new Str ({ example : 'Cloudflare' }), type : new Str ({ example : 'asn' }), }, { xml : { name : 'root' } } ), }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // ... } }","title":"Custom response formats"},{"location":"advanced-user-guide/custom-response-formats/#describing-a-binary-file","text":"import { OpenAPIRoute , Str } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { summary : 'My summary of a custom pdf file endpoint.' , responses : { '200' : { contentType : 'application/pdf' , schema : new Str ({ format : 'binary' }), }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // ... } }","title":"Describing a binary file:"},{"location":"advanced-user-guide/custom-response-formats/#describing-a-xml-response","text":"import { OpenAPIRoute , Str } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { summary : 'My summary of a custom pdf file endpoint.' , responses : { '200' : { contentType : 'application/xml' , schema : new Obj ( { code : new Str ({ example : '13335' }), name : new Str ({ example : 'Cloudflare' }), type : new Str ({ example : 'asn' }), }, { xml : { name : 'root' } } ), }, }, } async handle ( request : Request , env : any , context : any , data : any ) { // ... } }","title":"Describing a XML response:"},{"location":"advanced-user-guide/event-listener-worker/","text":"Worker using addEventListener \u00b6 If you want to use the addEventListener instead of exporting an object, you can define your worker like this: import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) addEventListener ( 'fetch' , ( event ) => event . respondWith ( router . handle ( event . request ))) You can also pass other event parameters to the endpoint, by adding them in the addEventListener function import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , waitUntil : any , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) addEventListener ( 'fetch' , ( event ) => event . respondWith ( router . handle ( event . request , event . waitUntil . bind ( event )))) Notice that, in this last example the endpoint is receiving an extra waitUntil parameter. Learn more about Cloudflare Workers addEventListener here .","title":"Worker using addEventListener"},{"location":"advanced-user-guide/event-listener-worker/#worker-using-addeventlistener","text":"If you want to use the addEventListener instead of exporting an object, you can define your worker like this: import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) addEventListener ( 'fetch' , ( event ) => event . respondWith ( router . handle ( event . request ))) You can also pass other event parameters to the endpoint, by adding them in the addEventListener function import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , waitUntil : any , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) addEventListener ( 'fetch' , ( event ) => event . respondWith ( router . handle ( event . request , event . waitUntil . bind ( event )))) Notice that, in this last example the endpoint is receiving an extra waitUntil parameter. Learn more about Cloudflare Workers addEventListener here .","title":"Worker using addEventListener"},{"location":"advanced-user-guide/hiding-routes-in-openapi-schema/","text":"Hiding routes can be archived by registering your endpoints in the original itty-router ,as shown here: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () router . original . get ( '/todos/:id' , ({ params }) => new Response ( `Todo # ${ params . id } ` ) ) This endpoint will still be accessible, but will not be shown in the schema. Defining redirects \u00b6 This is also useful to define redirects, like this: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { TaskFetch } from './tasks' const router = OpenAPIRouter () // Redirect to docs page router . original . get ( '/' , ( request ) => Response . redirect ( ` ${ request . url } docs` , 302 )) export default { fetch : router.handle , }","title":"Hiding routes in openapi schema"},{"location":"advanced-user-guide/hiding-routes-in-openapi-schema/#defining-redirects","text":"This is also useful to define redirects, like this: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { TaskFetch } from './tasks' const router = OpenAPIRouter () // Redirect to docs page router . original . get ( '/' , ( request ) => Response . redirect ( ` ${ request . url } docs` , 302 )) export default { fetch : router.handle , }","title":"Defining redirects"},{"location":"advanced-user-guide/openai-plugin/","text":"OpenAI plugin support \u00b6 In the aiPlugin field you can define all fields from the plugin manifest This library include default values for the following plugin manifest fields: import { AuthType , SchemaVersion , APIType } from '@cloudflare/itty-router-openapi' const default = { schema_version : SchemaVersion.V1 , auth : { type : AuthType . NONE , }, api : { type : APIType . OPENAPI , has_user_authentication : false , url : '/openai.json' , // The path to the schema will be the same as the `openapi_url` field in the router configuration } } Taking into consideration the default values included, we can build a very minimal configuration, assuming the api doesn't require Auth: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter ({ aiPlugin : { name_for_human : 'Cloudflare Radar API' , name_for_model : 'cloudflare_radar' , description_for_human : \"Get data insights from Cloudflare's point of view.\" , description_for_model : \"Plugin for retrieving the data based on Cloudflare Radar's data. Use it whenever a user asks something that might be related to Internet usage, eg. outages, Internet traffic, or Cloudflare Radar's data in particular.\" , contact_email : 'radar@cloudflare.com' , legal_info_url : 'https://www.cloudflare.com/website-terms/' , logo_url : 'https://cdn-icons-png.flaticon.com/512/5969/5969044.png' , }, }) // ... Now when calling the /.well-known/ai-plugin.json path in our worker, we will see a full ai-plugin schema, that automatically points to our generated OpenAPI 3 Schema. Serving the OpenAI schema from multiple domains/hosts \u00b6 When serving from multiple domains, the OpenAPI schema should automatically update to the domain being served. Thats why we made the aiPlugin.api.url to allow relative paths, and when doing so, the itty-router-openapi will automatically fill the domain. import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter ({ aiPlugin : { // other fields api : { url : '/my-schema-for-openai.json' , }, }, }) // ... Then when calling for https://example.com/.well-known/ai-plugin.json the response will have the absolut url { ... api: { url: 'https://example.com/my-schema-for-openai.json' } }","title":"OpenAI plugin support"},{"location":"advanced-user-guide/openai-plugin/#openai-plugin-support","text":"In the aiPlugin field you can define all fields from the plugin manifest This library include default values for the following plugin manifest fields: import { AuthType , SchemaVersion , APIType } from '@cloudflare/itty-router-openapi' const default = { schema_version : SchemaVersion.V1 , auth : { type : AuthType . NONE , }, api : { type : APIType . OPENAPI , has_user_authentication : false , url : '/openai.json' , // The path to the schema will be the same as the `openapi_url` field in the router configuration } } Taking into consideration the default values included, we can build a very minimal configuration, assuming the api doesn't require Auth: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter ({ aiPlugin : { name_for_human : 'Cloudflare Radar API' , name_for_model : 'cloudflare_radar' , description_for_human : \"Get data insights from Cloudflare's point of view.\" , description_for_model : \"Plugin for retrieving the data based on Cloudflare Radar's data. Use it whenever a user asks something that might be related to Internet usage, eg. outages, Internet traffic, or Cloudflare Radar's data in particular.\" , contact_email : 'radar@cloudflare.com' , legal_info_url : 'https://www.cloudflare.com/website-terms/' , logo_url : 'https://cdn-icons-png.flaticon.com/512/5969/5969044.png' , }, }) // ... Now when calling the /.well-known/ai-plugin.json path in our worker, we will see a full ai-plugin schema, that automatically points to our generated OpenAPI 3 Schema.","title":"OpenAI plugin support"},{"location":"advanced-user-guide/openai-plugin/#serving-the-openai-schema-from-multiple-domainshosts","text":"When serving from multiple domains, the OpenAPI schema should automatically update to the domain being served. Thats why we made the aiPlugin.api.url to allow relative paths, and when doing so, the itty-router-openapi will automatically fill the domain. import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter ({ aiPlugin : { // other fields api : { url : '/my-schema-for-openai.json' , }, }, }) // ... Then when calling for https://example.com/.well-known/ai-plugin.json the response will have the absolut url { ... api: { url: 'https://example.com/my-schema-for-openai.json' } }","title":"Serving the OpenAI schema from multiple domains/hosts"},{"location":"advanced-user-guide/openapi-schema-customizations/","text":"OpenAPI schema customizations \u00b6 Besides adding a schema to your endpoints, its also recommended you customize your schema. This can be done by passing the schema argument when creating your router. All OpenAPI Fixed Fields are available. The example bellow will change the schema title, and add a Bearer token authentication to all endpoints const router = OpenAPIRouter ({ schema : { info : { title : 'Radar Worker API' , version : '1.0' , }, components : { securitySchemes : { bearerAuth : { type : 'http' , scheme : 'bearer' , }, }, }, security : [ { bearerAuth : [], }, ], }, })","title":"OpenAPI schema customizations"},{"location":"advanced-user-guide/openapi-schema-customizations/#openapi-schema-customizations","text":"Besides adding a schema to your endpoints, its also recommended you customize your schema. This can be done by passing the schema argument when creating your router. All OpenAPI Fixed Fields are available. The example bellow will change the schema title, and add a Bearer token authentication to all endpoints const router = OpenAPIRouter ({ schema : { info : { title : 'Radar Worker API' , version : '1.0' , }, components : { securitySchemes : { bearerAuth : { type : 'http' , scheme : 'bearer' , }, }, }, security : [ { bearerAuth : [], }, ], }, })","title":"OpenAPI schema customizations"},{"location":"user-guide/cors/","text":"","title":"Cors"},{"location":"user-guide/first-steps/","text":"First, create a new directory, and use wrangler , our command line tool for building Cloudflare Workers, which we assume you have installed already, to initialize the project: mkdir openapi-example && cd openapi-example wrangler init And install itty-router-openapi npm i @cloudflare/itty-router-openapi --save Then in the src/index.ts place this, the smallest router you can have in itty-router-openapi. import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () export default { fetch : router.handle , } Now when running wrangler dev you see server logs wrangler dev \u26c5\ufe0f wrangler 3.4.0 ------------------ wrangler dev now uses local mode by default, powered by \ud83d\udd25 Miniflare and \ud83d\udc77 workerd. To run an edge preview session for your Worker, use wrangler dev --remote \u2394 Starting local server... \u2394 Reloading local server... [mf:inf] Ready on http://127.0.0.1:8787/ [mf:inf] Updated and ready on http://127.0.0.1:8787/ You can now open http://127.0.0.1:8787/docs in your browser to see the Swagger UI, that will hold your future endpoints. // TODO screenshot /docs You can also open the http://127.0.0.1:8787/redocs to see an alternative version with the same endpoints. // TODO screenshot /redocs Creating your first endpoint \u00b6 This is the simplest endpoint you can create, that don't receive any parameters, neither have a response format defined. import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ListEndpoint extends OpenAPIRoute { async handle ( request : Request , env : any , context : any , data : any ) { return [ \"cloudflare\" , \"workers\" ] } } After this you must register the endpoint in the initial router, so your src/index.ts should look something like this: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () router . get ( '/list/' , ListEndpoint ) export default { fetch : router.handle , } Now when opening the /docs you will see your new endpoint and be able to test it right away. // TODO screenshot /docs with endpoint","title":"First steps"},{"location":"user-guide/first-steps/#creating-your-first-endpoint","text":"This is the simplest endpoint you can create, that don't receive any parameters, neither have a response format defined. import { OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ListEndpoint extends OpenAPIRoute { async handle ( request : Request , env : any , context : any , data : any ) { return [ \"cloudflare\" , \"workers\" ] } } After this you must register the endpoint in the initial router, so your src/index.ts should look something like this: import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' const router = OpenAPIRouter () router . get ( '/list/' , ListEndpoint ) export default { fetch : router.handle , } Now when opening the /docs you will see your new endpoint and be able to test it right away. // TODO screenshot /docs with endpoint","title":"Creating your first endpoint"},{"location":"user-guide/header-parameters/","text":"","title":"Header parameters"},{"location":"user-guide/nested-routers/","text":"7. Nested Routers \u00b6 For big projects, having all routes in the same file can be chaotic. In this example we split some routes to a different router // api/attacks/router.ts import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' export const attacksRouter = OpenAPIRouter ({ base : '/api/v1/attacks' }) attacksRouter . get ( '/layer3/timeseries' , AttacksLayer3Timeseries ) // router.ts import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { attacksRouter } from 'api/attacks/router' export const router = OpenAPIRouter ({ schema : { info : { title : 'Radar Worker API' , version : '1.0' , }, }, }) router . all ( '/api/v1/attacks/*' , attacksRouter ) // Other routes router . get ( '/api/v1/bgp/timeseries' , BgpTimeseries ) Now run wrangler dev and go to /docs with your browser, here you can verify that all nested routers appear correctly and you are able to call every endpoint.","title":"Nested routers"},{"location":"user-guide/nested-routers/#7-nested-routers","text":"For big projects, having all routes in the same file can be chaotic. In this example we split some routes to a different router // api/attacks/router.ts import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' export const attacksRouter = OpenAPIRouter ({ base : '/api/v1/attacks' }) attacksRouter . get ( '/layer3/timeseries' , AttacksLayer3Timeseries ) // router.ts import { OpenAPIRouter } from '@cloudflare/itty-router-openapi' import { attacksRouter } from 'api/attacks/router' export const router = OpenAPIRouter ({ schema : { info : { title : 'Radar Worker API' , version : '1.0' , }, }, }) router . all ( '/api/v1/attacks/*' , attacksRouter ) // Other routes router . get ( '/api/v1/bgp/timeseries' , BgpTimeseries ) Now run wrangler dev and go to /docs with your browser, here you can verify that all nested routers appear correctly and you are able to call every endpoint.","title":"7. Nested Routers"},{"location":"user-guide/path-parameters/","text":"Please make sure to read the Types section before continuing. You can declare Path parameters in the parameters property of your endpoint schema. The validated data is available under data.params.<name> , where name is the key used inside the parameters property. Basic parameter \u00b6 For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. import { OpenAPIRoute , Path , Int } from '@cloudflare/itty-router-openapi' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : Path ( Int , { description : 'ToDo ID' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { todoId } = data . params // ... } } Then remember to register the endpoint with the parameter name in the url starting with : router . get ( '/todos/:todoId' , ToDoFetch ) Advanced parameters \u00b6 If you need a more advanced control over the validation, you should use Zod . Here is an example that allows only number lower than 10 in the path import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : Path ( z . coerce . number (). lt ( 10 ), { description : 'ToDo ID' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { todoId } = data . params // ... } }","title":"Path parameters"},{"location":"user-guide/path-parameters/#basic-parameter","text":"For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. import { OpenAPIRoute , Path , Int } from '@cloudflare/itty-router-openapi' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : Path ( Int , { description : 'ToDo ID' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { todoId } = data . params // ... } } Then remember to register the endpoint with the parameter name in the url starting with : router . get ( '/todos/:todoId' , ToDoFetch )","title":"Basic parameter"},{"location":"user-guide/path-parameters/#advanced-parameters","text":"If you need a more advanced control over the validation, you should use Zod . Here is an example that allows only number lower than 10 in the path import { OpenAPIRoute , Path } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { todoId : Path ( z . coerce . number (). lt ( 10 ), { description : 'ToDo ID' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { todoId } = data . params // ... } }","title":"Advanced parameters"},{"location":"user-guide/query-parameters/","text":"Please make sure to read the Types section before continuing. You can declare Query parameters in the parameters property of your endpoint schema. The validated data is available under data.query.<name> , where name is the key used inside the parameters property. Basic parameter \u00b6 For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. import { OpenAPIRoute , Query , Int } from '@cloudflare/itty-router-openapi' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { limit : Query ( Int , { description : 'Number of results to return' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } } Advanced parameters \u00b6 If you need a more advanced control over the validation, you should use Zod . While the previous example will work well, you might want more control, like make the limit something between 10 and 100. import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'List ToDos' , parameters : { limit : Query ( z . coerce . number (). gte ( 10 ). lte ( 100 ), { description : 'Number of results to return' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } }","title":"Query parameters"},{"location":"user-guide/query-parameters/#basic-parameter","text":"For basic parameters you are fine using the Native types, this should cover almost everything you need to build a big project. import { OpenAPIRoute , Query , Int } from '@cloudflare/itty-router-openapi' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Fetch a ToDo' , parameters : { limit : Query ( Int , { description : 'Number of results to return' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } }","title":"Basic parameter"},{"location":"user-guide/query-parameters/#advanced-parameters","text":"If you need a more advanced control over the validation, you should use Zod . While the previous example will work well, you might want more control, like make the limit something between 10 and 100. import { OpenAPIRoute , Query } from '@cloudflare/itty-router-openapi' import { z } from 'zod' export class ToDoFetch extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'List ToDos' , parameters : { limit : Query ( z . coerce . number (). gte ( 10 ). lte ( 100 ), { description : 'Number of results to return' , }), }, } async handle ( request : Request , env : any , context : any , data : any ) { const { limit } = data . query // ... } }","title":"Advanced parameters"},{"location":"user-guide/request-body/","text":"Example requestBody: \u00b6 requestBody = { datasetId : new Int ({ example : 3 }), search : new Str (), } Request Body Validation \u00b6 The requestBody is defined the same way as the normal parameters . The validated data will be available inside the body property in the data argument. Remember that requestBody is only available when the route method is not GET . export class ToDoCreate extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Create a new Todo' , requestBody : { title : String , description : new Str ({ required : false }), type : new Enumeration ({ values : { nextWeek : 'nextWeek' , nextMonth : 'nextMonth' , } }) }, responses : { '200' : { schema : { todo : { id : 123 , title : 'My title' , }, }, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { const { body } = data // Actually insert the data somewhere return { todo : { id : 123 , title : body.title , }, } } } ... router . post ( '/todos' , ToDoCreate )","title":"Request body"},{"location":"user-guide/request-body/#example-requestbody","text":"requestBody = { datasetId : new Int ({ example : 3 }), search : new Str (), }","title":"Example requestBody:"},{"location":"user-guide/request-body/#request-body-validation","text":"The requestBody is defined the same way as the normal parameters . The validated data will be available inside the body property in the data argument. Remember that requestBody is only available when the route method is not GET . export class ToDoCreate extends OpenAPIRoute { static schema = { tags : [ 'ToDo' ], summary : 'Create a new Todo' , requestBody : { title : String , description : new Str ({ required : false }), type : new Enumeration ({ values : { nextWeek : 'nextWeek' , nextMonth : 'nextMonth' , } }) }, responses : { '200' : { schema : { todo : { id : 123 , title : 'My title' , }, }, }, }, } async handle ( request : Request , env : any , context : any , data : any ) { const { body } = data // Actually insert the data somewhere return { todo : { id : 123 , title : body.title , }, } } } ... router . post ( '/todos' , ToDoCreate )","title":"Request Body Validation"},{"location":"user-guide/response-model/","text":"Example responses: \u00b6 Example with common values responses = { '200' : { schema : { result : { series : { timestamps : [ '2023-01-01 00:00:00' ], values : [ 0.56 ], }, }, }, }, } Example with defined types responses = { '200' : { schema : { result : { meta : { confidenceInfo : schemaDateRange , dateRange : schemaDateRange , aggInterval : schemaAggInterval , lastUpdated : new DateTime (), }, series : { timestamps : [ new DateTime ()], values : [ new Str ({ example : 0.56 })], }, }, }, }, }","title":"Response model"},{"location":"user-guide/response-model/#example-responses","text":"Example with common values responses = { '200' : { schema : { result : { series : { timestamps : [ '2023-01-01 00:00:00' ], values : [ 0.56 ], }, }, }, }, } Example with defined types responses = { '200' : { schema : { result : { meta : { confidenceInfo : schemaDateRange , dateRange : schemaDateRange , aggInterval : schemaAggInterval , lastUpdated : new DateTime (), }, series : { timestamps : [ new DateTime ()], values : [ new Str ({ example : 0.56 })], }, }, }, }, }","title":"Example responses:"},{"location":"user-guide/router-options/","text":"Options API \u00b6 OpenAPIRouter(options = {}) \u00b6 Name Type(s) Description Examples base string prefixes all routes with this string Router({ base: '/api' }) routes array of routes array of manual routes for preloading see documentation schema object Object of the common OpenAPI customizations see documentation docs_url string or null or undefined Path for swagger docs, null : disabled, undefined : /docs /docs redoc_url string or null or undefined Path for redoc docs, null : disabled, undefined : /redocs /redocs openapi_url string or null or undefined Path for openapi schema, null : disabled, undefined : /openapi.json /openapi.json raiseUnknownParameters boolean This will raise validation errors when an endpoint received an unknown query parameter true generateOperationIds boolean This will generate operation ids from class names for your endpoints when nothing is provided true aiPlugin object or undefined Object that will be used to generate the ai-plugin.json schema see schema bellow aiPlugin \u00b6 Example configurations are available here Name Type(s) Description Examples schema_version SchemaVersion or string or undefined Schema Version, undefined : defaults v1 v1 name_for_model string Name for model cloudflare_radar name_for_human string Name for Human Cloudflare Radar API description_for_model string Description for model Plugin for retrieving the data based on Cloudflare Radar's data. Use it whenever a user asks something that might be related to Internet usage, eg. outages, Internet traffic, or Cloudflare Radar's data in particular. description_for_human string Description for human Get data insights from Cloudflare's point of view. logo_url string Logo url https://cdn-icons-png.flaticon.com/512/5969/5969044.png contact_email string Contact email radar@cloudflare.com legal_info_url string Legal info url https://www.cloudflare.com/website-terms/ auth object or undefined Object for Auth configuration, undefined : defaults to no Auth {type: AuthType.USER_HTTP, authorization_type: 'bearer'} api object or undefined Object for Api configuration, undefined : defaults to openapi.json spec {type: APIType.OPENAPI, has_user_authentication: false, url: '/openai.json'} is_dev boolean or undefined Boolean to let chatgpt know it is in development mode, undefined : defaults to false true Schema types \u00b6 Schema types can be used in parameters, requestBody and responses. All of theses Types can be imported like import { Email } from '@cloudflare/itty-router-openapi' Name Arguments Num description example default Int description example default Str description example default format Enumeration description example default values enumCaseSensitive DateTime description example default DateOnly description example default Bool description example default Regex description example default pattern patternError Email description example default Uuid description example default Hostname description example default Ipv4 description example default Ipv6 description example default In order to make use of the enum argument you should pass your Enum values to the Enumeration class, as shown bellow. 1. Cloudflare ES6 Module Worker \u00b6 In the Module Worker format, the parameters binding is different. Instead of the worker only having access to the event argument, that argument is split into request , env , context . And as said above, the data object (that contains the validated parameters) is always the last argument that the handle() function receives. import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , env , context , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) export default { fetch : router.handle } Otherwise, if you don't need the new env and context parameters, you can remove theses like the next example import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) export default { fetch : ( request ) => router . handle ( request ) } Learn more about Cloudflare Module Worker format here .","title":"Router options"},{"location":"user-guide/router-options/#options-api","text":"","title":"Options API"},{"location":"user-guide/router-options/#openapirouteroptions","text":"Name Type(s) Description Examples base string prefixes all routes with this string Router({ base: '/api' }) routes array of routes array of manual routes for preloading see documentation schema object Object of the common OpenAPI customizations see documentation docs_url string or null or undefined Path for swagger docs, null : disabled, undefined : /docs /docs redoc_url string or null or undefined Path for redoc docs, null : disabled, undefined : /redocs /redocs openapi_url string or null or undefined Path for openapi schema, null : disabled, undefined : /openapi.json /openapi.json raiseUnknownParameters boolean This will raise validation errors when an endpoint received an unknown query parameter true generateOperationIds boolean This will generate operation ids from class names for your endpoints when nothing is provided true aiPlugin object or undefined Object that will be used to generate the ai-plugin.json schema see schema bellow","title":"OpenAPIRouter(options = {})"},{"location":"user-guide/router-options/#aiplugin","text":"Example configurations are available here Name Type(s) Description Examples schema_version SchemaVersion or string or undefined Schema Version, undefined : defaults v1 v1 name_for_model string Name for model cloudflare_radar name_for_human string Name for Human Cloudflare Radar API description_for_model string Description for model Plugin for retrieving the data based on Cloudflare Radar's data. Use it whenever a user asks something that might be related to Internet usage, eg. outages, Internet traffic, or Cloudflare Radar's data in particular. description_for_human string Description for human Get data insights from Cloudflare's point of view. logo_url string Logo url https://cdn-icons-png.flaticon.com/512/5969/5969044.png contact_email string Contact email radar@cloudflare.com legal_info_url string Legal info url https://www.cloudflare.com/website-terms/ auth object or undefined Object for Auth configuration, undefined : defaults to no Auth {type: AuthType.USER_HTTP, authorization_type: 'bearer'} api object or undefined Object for Api configuration, undefined : defaults to openapi.json spec {type: APIType.OPENAPI, has_user_authentication: false, url: '/openai.json'} is_dev boolean or undefined Boolean to let chatgpt know it is in development mode, undefined : defaults to false true","title":"aiPlugin"},{"location":"user-guide/router-options/#schema-types","text":"Schema types can be used in parameters, requestBody and responses. All of theses Types can be imported like import { Email } from '@cloudflare/itty-router-openapi' Name Arguments Num description example default Int description example default Str description example default format Enumeration description example default values enumCaseSensitive DateTime description example default DateOnly description example default Bool description example default Regex description example default pattern patternError Email description example default Uuid description example default Hostname description example default Ipv4 description example default Ipv6 description example default In order to make use of the enum argument you should pass your Enum values to the Enumeration class, as shown bellow.","title":"Schema types"},{"location":"user-guide/router-options/#1-cloudflare-es6-module-worker","text":"In the Module Worker format, the parameters binding is different. Instead of the worker only having access to the event argument, that argument is split into request , env , context . And as said above, the data object (that contains the validated parameters) is always the last argument that the handle() function receives. import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , env , context , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) export default { fetch : router.handle } Otherwise, if you don't need the new env and context parameters, you can remove theses like the next example import { OpenAPIRouter , OpenAPIRoute } from '@cloudflare/itty-router-openapi' export class ToDoList extends OpenAPIRoute { static schema = { ... } async handle ( request : Request , data : any ) { const { page } = data return { currentPage : page , nextPage : page + 1 , results : [ 'lorem' , 'ipsum' ], } } } const router = OpenAPIRouter () router . get ( '/todos' , ToDoList ) export default { fetch : ( request ) => router . handle ( request ) } Learn more about Cloudflare Module Worker format here .","title":"1. Cloudflare ES6 Module Worker"},{"location":"user-guide/security/","text":"","title":"Security"}]}